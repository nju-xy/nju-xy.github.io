<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="问题求解3算法导论整理动态规划动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。 最优子结构：问题的最优解由相关子问题的最优解构成，而这些子问题可以独立求解。 实现： 自顶向下的备忘算法（递归） 自底向上的动态规划算法（循环）  重构解每一次记录下子问题的最优解的结构 解题思">
<meta name="keywords" content="问题求解三,算法导论">
<meta property="og:type" content="article">
<meta property="og:title" content="算法导论整理">
<meta property="og:url" content="http://yoursite.com/2019/07/01/TC/index.html">
<meta property="og:site_name" content="XY&#39;s blog">
<meta property="og:description" content="问题求解3算法导论整理动态规划动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。 最优子结构：问题的最优解由相关子问题的最优解构成，而这些子问题可以独立求解。 实现： 自顶向下的备忘算法（递归） 自底向上的动态规划算法（循环）  重构解每一次记录下子问题的最优解的结构 解题思">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-17T02:29:16.432Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法导论整理">
<meta name="twitter:description" content="问题求解3算法导论整理动态规划动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。 最优子结构：问题的最优解由相关子问题的最优解构成，而这些子问题可以独立求解。 实现： 自顶向下的备忘算法（递归） 自底向上的动态规划算法（循环）  重构解每一次记录下子问题的最优解的结构 解题思">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/07/01/TC/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>算法导论整理 | XY's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XY's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/TC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法导论整理

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-01 10:55:42" itemprop="dateCreated datePublished" datetime="2019-07-01T10:55:42+08:00">2019-07-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-17 10:29:16" itemprop="dateModified" datetime="2019-01-17T10:29:16+08:00">2019-01-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="问题求解3算法导论整理"><a href="#问题求解3算法导论整理" class="headerlink" title="问题求解3算法导论整理"></a>问题求解3算法导论整理</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们成这样的解为问题的一个最优解，而不是最优解。</p>
<h3 id="最优子结构："><a href="#最优子结构：" class="headerlink" title="最优子结构："></a>最优子结构：</h3><p>问题的最优解由相关子问题的最优解构成，而这些子问题可以独立求解。</p>
<h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ul>
<li>自顶向下的备忘算法（递归）</li>
<li>自底向上的动态规划算法（循环）</li>
</ul>
<h3 id="重构解"><a href="#重构解" class="headerlink" title="重构解"></a>重构解</h3><p>每一次记录下子问题的最优解的结构</p>
<h3 id="解题思考过程"><a href="#解题思考过程" class="headerlink" title="解题思考过程"></a>解题思考过程</h3><ul>
<li>状态的表示</li>
<li>状态间的转移（转移方程）</li>
<li>解的表达</li>
<li>边界条件</li>
<li>计算顺序</li>
</ul>
<h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><ul>
<li>钢材切割问题（左边第一刀和右边剩下的）</li>
<li>矩阵链乘法</li>
<li>最长公共子序列问题（LCS）（考虑X和Y对后一个是否相等）</li>
<li>最优二叉搜索树（伪关键字）</li>
<li>最长递增子列（LIS）（LCS（A，SORT（A））；或者dp计算以A[i]结尾的子列的最大长度）</li>
</ul>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>贪心算法每一步都作出当时看起来最佳的最优解，希望这样的选择能得到全局最优解。</p>
<h3 id="最优子结构（同上）"><a href="#最优子结构（同上）" class="headerlink" title="最优子结构（同上）"></a>最优子结构（同上）</h3><h3 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>我们可以通过做出局部最优（贪心）选择来构造全局最优。即进行选择的时候，我们直接作出在当前问题汇总看来最优的选择，而不必考虑子问题的解。</p>
<h3 id="算法设计步骤"><a href="#算法设计步骤" class="headerlink" title="算法设计步骤"></a>算法设计步骤</h3><ul>
<li>将最优化问题转化为这样的形式：对齐作出一次选择之后，只剩下一个子问题需要求解。</li>
<li>证明作出贪心选择后，原问题总是存在最优解，即贪心选择是安全的。（替换法）</li>
<li>证明作出贪心选择后，剩余的子问题满足性质：其最优解和贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。</li>
</ul>
<h3 id="例：-1"><a href="#例：-1" class="headerlink" title="例："></a>例：</h3><ul>
<li>活动选择问题（总是选择最早结束的）</li>
<li>分数背包问题（01背包问题不行）</li>
<li>赫夫曼编码（找当前频率最低的两个合成一个新的结点）</li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="三个基本操作"><a href="#三个基本操作" class="headerlink" title="三个基本操作"></a>三个基本操作</h3><ul>
<li>MAKE-SET(x)：建立一个新的集合，唯一成员（因而是代表）是x；</li>
<li>UNION(x, y)：将包含x和y的两个动态几何合并为一个新的集合；</li>
<li>FIND-SET(x)：返回一个指针，指向包含x的唯一集合的代表。</li>
</ul>
<h3 id="链表表示"><a href="#链表表示" class="headerlink" title="链表表示"></a>链表表示</h3><p>每个链表有head和tail；</p>
<p>链表中每个成员有key，prev（指向head），next</p>
<p>时间复杂度：</p>
<ul>
<li>MAKE-SET O(1)</li>
<li>FIND-SET O(1)</li>
<li>UNION（简单实现） O(n)</li>
</ul>
<h3 id="简单加权合并启发式策略"><a href="#简单加权合并启发式策略" class="headerlink" title="简单加权合并启发式策略"></a>简单加权合并启发式策略</h3><ul>
<li>将较小的链表挂到较大的链表上</li>
</ul>
<h3 id="不相交集合森林"><a href="#不相交集合森林" class="headerlink" title="不相交集合森林"></a>不相交集合森林</h3><p>使用有根树来表示集合。<br>每棵树表示一个集合，树的根结点是该集合的代表元。<br>执行UNION操作时将两棵树的树根合并。<br>实现时可以用到两种改进运行时间的启发式策略。</p>
<p>（一）按秩合并</p>
<p>类似链表的加权合并启发式策略。为了易于分析，对于每个结点，维护一个秩，表示该结点高度的一个上界。</p>
<p>UNION操作</p>
<ul>
<li>如果根的秩不同，则让较大秩的根成为较小秩的根的父结点，但秩本身保持不变；</li>
<li>如果根的秩相同，则任意选择两个中的一个作为父结点，并使它的秩+1</li>
</ul>
<p>（二）路径压缩</p>
<ul>
<li>在FIND-SET操作中是查找路径中的每个结点直接指向根，不改变任何结点的秩。</li>
</ul>
<p>伪代码：</p>
<pre><code>MAKE-SET(x)
x.p = x
x.rank = 0

//摊还代价O(\alpha(n))
FIND-SET(x)
if x != x.p
    x.p = FIND-SET(x.p)
return x.p

UNION(x, y)
LINK(FIND-SET(x), FIND-SET(y))

//摊还代价O(\alpha(n))
LINK(x, y)
if(x.rank &gt; y.rank)
    y.p = x
else x.p = y
if(x.rank == y.rank)
    y.rank ++</code></pre><h3 id="例：-2"><a href="#例：-2" class="headerlink" title="例："></a>例：</h3><ul>
<li>确定无向图的连通分量</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h3><ul>
<li><p>每个连通图都含有一个生成树。</p>
</li>
<li><p>Kruskal算法：对于一个连通赋权图$G$，$G$的生成树$T$按下述方法构造：对于$T$的第一条边$e_1$，选择$G$的任一权值最小的边；对于$T$的第二条边$e_2$，在G剩下的边中选择权值最小的边；对于T的第三条边$e_3$，在$G$剩下的边中选择权值最小的边，且不与前面所选的边构成圈。继续这种做法，直至产生一个生成树。</p>
<pre><code>MST-KRUSKAL(G, w)
A = empty set
for each vertex v in G.V
    MAKE-SET(v)
sort the edges of G.E into  nondecreasing order by weight w
for each edge (u, v) in G.E, taken in nondecreasing order by weight
    if FIND-SET(v) != FIND-SET(u)
        A = A \cup {(u, v)}
        UNION(u, v)
return A</code></pre></li>
<li><p>Prim算法：对于一个连通赋权图$G$，$G$的一个生成树$T$由下述方法构造：对于$G$的任一顶点$u$，选择与$u$关联的且权值最小的边作为$T$的第一条边$e_1$。对于接下来的边$e_2$, $e_3$, …, $e_{n-1}$，在与一条已选边只有一个公共顶点的所有边中选择权值最小的边。</p>
<pre><code>MST-PRIM(G, w, r)
for each u in G.V
    u.key = $\infty$
    u.p = NIL
r.key = 0
Q = G.V
while Q != $\emptyset$
    u = EXTRACT-MIN(Q)
    for each v in G.Adj[u]
        if v in Q and w(u, v) &lt; v.key
            v.p = u
            v.key = w(u, v)</code></pre></li>
</ul>
<ul>
<li>两种算法都是贪心算法，Kruskal时间复杂度为$O(E\lg E)$, Prim时间复杂度用二叉最小堆为$O(E\lg V)$，用斐波那契堆为$O(E + V\lg V)$.</li>
</ul>
<h2 id="图的表示和遍历"><a href="#图的表示和遍历" class="headerlink" title="图的表示和遍历"></a>图的表示和遍历</h2><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li><p>邻接链表 和 邻接矩阵</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先-bfs"><a href="#广度优先-bfs" class="headerlink" title="广度优先 bfs"></a>广度优先 bfs</h4></li>
<li><p>从一个源结点s开始，每次从已发现的结点向未发现的结点扩展</p>
</li>
<li><p>算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点</p>
</li>
<li><p>用三种颜色标记结点的访问状态：<br>白色：未被发现<br>黑色：本身被发现且所有与之相连的结点都已经被发现<br>灰色：本身被发现且与之相连的结点中存在未被发现的</p>
</li>
<li><p>总时间复杂度： O(V+E)</p>
</li>
<li><p>伪代码</p>
<pre><code>BFS(G, s)
for each vertex u in G.V - {s}
    u.color = WHITE
    u.d = \infty
    u.p = NIL
s.color = GRAY
s.d = 0
s.p = NIL
Q = \emptyset
ENQUEUE(Q, s)
while Q isn&apos;t empty
    u = DEQUEUE(Q)
    for each v in G.Adj[u]
        if v.color == WHITE
            v.color = GREY
            v.d = u.d + 1
            v.p = u
            ENQUEUE(Q, v)
        u.color = BLACK</code></pre><h4 id="深度优先-dfs"><a href="#深度优先-dfs" class="headerlink" title="深度优先 dfs"></a>深度优先 dfs</h4></li>
<li><p>时间戳： 每个结点v有两个时间戳</p>
<ul>
<li>第一个时间戳v.d记录结点v第一次被发现的时间（染上灰色的时候）</li>
<li>第二个时间戳v.f记录搜索完成对v的邻接链表扫描的时间（图上黑色的时候）<br>时间戳都是处于1和2|V|之间的整数<br>u.d &lt; u.f</li>
</ul>
</li>
<li><p>代码 </p>
<pre><code>DFS(G)
for each vertex u in G.V
     u.color = WHITE
     u.p = NIL
time = 0
for each vertex u in G.V
    if u.color == WHITE
        DFS-VISIT(G, u)

DFS-VISIT(G, u)
time ++
u.d = time
u.color = GRAY
for each v in G.Adj[u] 
    if v.color == WHITE
        v.p = u
        DFS-VISIT(G, v)
u.color = BLACK
time ++
u.f = time</code></pre></li>
<li><p>括号化定理，后代区间嵌套，白色路径定理</p>
</li>
<li><p>边的分类</p>
<ul>
<li>树边：深度优先森林中的边</li>
<li>前向边F：从祖先指向后代</li>
<li>后向边B：从后代指向祖先（包括有向图中的自循环）</li>
<li>横向边C：两端点无血缘关系</li>
</ul>
</li>
<li><p>dfs中每条边要么是树边，要么是后向边</p>
</li>
</ul>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul>
<li><p>有向无环图</p>
</li>
<li><p>如果图$G$包含边$(u, v)$，则结点$u$在拓扑排序中处于结点$v$的前面。</p>
</li>
<li><p>伪代码</p>
<pre><code>TOPOLOGICAL-SORT
1 call DFS(G) to compute finishing times v.f for each vertex v
2 as each vertex is finished, insert it onto the front of a linked list
3 return the linked list</code></pre></li>
<li><p>引理22.11 一个有向图$G$是无环的当且仅当对齐进行深度优先搜索不产生后向边。</p>
</li>
</ul>
<h4 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h4><ul>
<li><p>有向图$G$的强连通分量是一个最大结点集合 $C\subset V$，对于该集合中任意一对结点u和v来说，路径u-&gt;v和路径v-&gt;u同时存在，也就是说，结点u和结点v可以互相到达。</p>
</li>
<li><p>算法伪代码：</p>
<pre><code>STRONGLY-CONNECTED-COMPONENTS(G)
1 call DFS(G) to compute finishing times u.f for each vertex u
2 compute G^T
3 call DFS(G^T), but in the main loop of DFS, consider the verteces
  in order of decreasing u.f
4 output the verteces of each tree in the depth-first forest 
  in line 3 as a seperate strongly connected component</code></pre></li>
<li><p>时间复杂度：$\theta(V+E)$</p>
</li>
<li><p>分量图的关键性质：是一个有向无环图</p>
</li>
<li><p>半连通：u-&gt;v 或 v-&gt;u</p>
</li>
</ul>
<h2 id="单源最短路径算法"><a href="#单源最短路径算法" class="headerlink" title="单源最短路径算法"></a>单源最短路径算法</h2><pre><code>INITIALIZE-SINGLE-SOURCE(G, s)
1 for each vertex v in G.V
2     v.d = \infty
3     v.p = NIL
4 s.d = 0

RELAX(u, v, w)
1 if v.d &gt; u.d + w(u, v)
2     v.d = u.d + w(u, v)
3     v.p = u</code></pre><ul>
<li><p>最短路径和松弛操作的性质</p>
<ul>
<li>三角不等式性质：对任何边$(u, v) \in E$, 有$\delta (s, v)\le \delta (s, u) + w(u, v)$.</li>
<li>上界性质：<br>对所有点v，有$v.d\ge \delta(s, v)$, 一旦$v.d$取值达到$\delta(s, v)$，就不会再变化。</li>
<li>非路径性质：如果s和v之间不存在路径，则总是有$v.d = \delta(s, v) = \infty$.</li>
<li>收敛性质：对于结点$v$，若有s~&gt;u-&gt;v是图$G$中的一条最短路径，并且在对边$(u, v)$进行松弛前的任意时间有$u.d=\delta (s, u)$，则在之后的所有时间有$u.d = \delta(s, v)$.</li>
<li>路径松弛性质：如果$p=&lt;v_0, v_1, …, v_k&gt;$是从源结点$s=v_0$到结点$v_k$的一条最短路径，并且我们队p中的边所进行的松弛的次序为$(v_0, v_1)$, $(v_1, v_2)$, …, $(v_{k-1}, v_k)$，则$v_k.d =\delta(s,v_k)$.</li>
<li>前驱子图性质：对于所有节点$v\in V$, 一旦$v.d = \delta(s, v)$，则前驱子图为一颗根结点为$s$的最短路径树。<h3 id="BELLMAN-FORD算法"><a href="#BELLMAN-FORD算法" class="headerlink" title="BELLMAN-FORD算法"></a>BELLMAN-FORD算法</h3></li>
</ul>
</li>
<li><p>代码</p>
<pre><code>BELLMAN-FORD(G, w, s)
1 INITIALIZE-SINGLE-SOURCE(G, s)
2 for i = 1 to |G.V| - 1
3     for each edge (u, v) in G.E
4         RELAX(u, v, w)
5 for each edge (u, v) in G.E
6     if v.d &gt; u.d + w(u, v)
7         return false
8 return true</code></pre></li>
<li><p>时间复杂度$O(VE)$</p>
</li>
</ul>
<h3 id="有向无环图中的单源最短路径"><a href="#有向无环图中的单源最短路径" class="headerlink" title="有向无环图中的单源最短路径"></a>有向无环图中的单源最短路径</h3><ul>
<li><p>代码</p>
<pre><code>DAG-SHORTEST-PATH(G, w, s)
1 topologically sort the vertices of G
2 INITIALIZE-SINGLE-SOURCE(G, s)
3 for each vertex u, taken in topologically sorted order
    for each vertex v in G.Adj[u]
        RELAX(u, v, w)</code></pre></li>
<li><p>时间复杂度 $O(V+E)$</p>
</li>
<li><p>找最长路径，则将所有权重变成负的，或者初始化为负无穷，RELAX过程 &gt; 变为 &lt;</p>
</li>
</ul>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul>
<li><p>有向图中单源最短路径问题，要求所有边的权重非负</p>
</li>
<li><p>代码</p>
<pre><code>DIJKSTRA(G, w, s)
1 INITIALIZE-SINGLE-SOURCE(G, s)
2 S = \emptyset
3 Q = G.V
4 while Q != \emptyset
5    u = EXTRACT-MIN(Q)
6    S = S \cup {u}
7    for each vertex v in G.Adj[u]
8        RELAX(u, v, w)</code></pre></li>
<li><p>时间复杂度：$O((V+E)\lg V)$; 若源结点可达所有点，则为$O(E\lg V)$. 用斐波那契堆可以达到$O(VlgV + E)$.</p>
</li>
<li><p>实际用C++实现的时候，因为优先队列不能直接decrease_key，不需要一次性push所有的点，到达之后再push，同时记录每个点有没有遍历过。</p>
</li>
</ul>
<h2 id="多源最短路径算法"><a href="#多源最短路径算法" class="headerlink" title="多源最短路径算法"></a>多源最短路径算法</h2><h3 id="“矩阵乘法”"><a href="#“矩阵乘法”" class="headerlink" title="“矩阵乘法”"></a>“矩阵乘法”</h3><ul>
<li><p>每次将最短路径拓展了一条边！</p>
</li>
<li><p>代码</p>
<pre><code>EXTEND-SHORTEST-PATHES(L, W)
n = L.rows
for i = 1 to n
    for j = 1 to n 
        l&apos;_{ij} = \infty
        for k = 1 to n
            l&apos;_{ij} = min(l&apos;_{ij}, l_{ik} + w_{kj})
return L&apos;</code></pre></li>
<li><p>类似于矩阵乘法</p>
</li>
<li><p>每一步拓展时间复杂度$O(n^3)$</p>
</li>
<li><p>用类似快速幂计算，时间复杂度$\Theta(n^3\lg n)$</p>
</li>
<li><p>垃圾算法基本不用</p>
</li>
</ul>
<h3 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h3><ul>
<li><p>递归定义$d_{ij}^k$如下：<br>$$d_{ij}^k = \begin{cases}<br>w_{ij}, &amp;\text{k = 0}\\<br>min(d_{ij}^{k-1}, d_{ik}^{k-1} + d_{kj}^{k-1}), &amp;\text{k &gt; 0}<br>\end{cases}$$</p>
</li>
<li><p>代码</p>
<pre><code>FLOYD-WARSHALL(W)
n = W.rows
for k = 1 to n
    for i = 1 to n
        for j = 1 to n
            d_{ij} = min(d_{ij}, d_{ik} + d_{kj})</code></pre></li>
<li><p>注：书上初始代码是用n个矩阵来记录的，但是实际上没必要。</p>
</li>
<li><p>时间复杂度$\Theta (n^3)$.</p>
</li>
<li><p>构建最短路径：</p>
<ul>
<li>递归公式：<br>$$\pi_{ij}^0 = \begin{cases}<br>NIL, &amp;i = j ; or ; w_{ij} = \infty\\<br>i, &amp;else<br>\end{cases}$$<br>$$\pi_{ij}^k = \begin{cases}<br>\pi_{ij}^{k-1}, &amp;d_{ij}^{k-1} \le d_{ik}^{k-1} + d_{kj}^{k-1}\\<br>\pi_{kj}^{k-1}, &amp;else<br>\end{cases}$$</li>
</ul>
</li>
<li><p>计算有向图的传递闭包也用类似的算法（略）</p>
</li>
<li><p>对于负权环，检查对角线上的值是否为负即可。</p>
</li>
</ul>
<h3 id="用于稀疏图的Johnson算法"><a href="#用于稀疏图的Johnson算法" class="headerlink" title="用于稀疏图的Johnson算法"></a>用于稀疏图的Johnson算法</h3><ul>
<li>技术：重新赋予权重使新的图满足<ul>
<li>所有权重都为非负值</li>
<li>新图中的最短路径就是旧图中的最短路径</li>
</ul>
</li>
<li>赋值方法：</li>
</ul>
<p>$$\hat{w}(u,v) = w(u,v)+h(u)-h(v)$$<br>$$h(u) = \delta(s, u)$$</p>
<ul>
<li>解释：<ul>
<li>先增加一个新结点 s，该点到原先各结点都有边相连，权重为 0</li>
<li>对新图进行一次Bellman-Ford算法，寻找是否有负权重环路</li>
<li>没有负权重环，就给每条边重新赋值。</li>
<li>然后对每个点进行Dijkstra</li>
<li>最后将最短路径的权重恢复，并存入矩阵D中返回</li>
</ul>
</li>
<li>时间复杂度：<ul>
<li>二叉最小优先队列实现Dijkstra：$O(VE\lg V)$</li>
<li>斐波那契堆：$O(V^2 \lg V + VE)$</li>
<li>稀疏图中比Floyd好</li>
</ul>
</li>
</ul>
<h2 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h2><h3 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h3><ul>
<li>有向图$G=(V,E)$</li>
<li>图中，每条边<br>$(u,v)\in E$ 有一个非负的容量值$c(u,v)\ge 0$</li>
<li>如果$(u,v) \notin E$，定义 $c(u,v)=0$</li>
<li>如果边集合$E$包含一条边$(u,v)$，则图中不存在反方向的边$(v,u)$</li>
<li>有源结点s和汇点t</li>
<li>流网络图是连通的</li>
<li>除源结点外的每个结点都至少有一条进入的边，$|E| \ge |V| - 1$.</li>
</ul>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>设$G=(V,E)$ 为一个流网络，其容量函数为c。设$s$为网络的源结点，$t$为汇点。$G$中的流是一个实值函数$f:V×V→R$，满足下面两条性质：</p>
<ul>
<li>流量限制：对于所有节点$u, v \in V$，要求 $0\le f(u, v) \le c(u, v)$.</li>
<li>流量守恒：对于所有的结点 $u \in V - {s, t}$，要求<br>$$\sum _{v\in V} f(v, u) = \sum _{v\in V} f(u, v)$$</li>
<li>去掉反平行边：将其中一条分为两条，加入一个新的结点。</li>
<li>多个源结点和多个汇点：超级源结点和超级汇点。</li>
<li>点容量限制：把一个点拆成两个点（入点和出点），其中用一条容量为原来的点容量的边连接。</li>
</ul>
<h3 id="Ford-Fulkerson方法"><a href="#Ford-Fulkerson方法" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h3><pre><code>FORD-FULEKERSON-METHOD(G, s, t)
initialize flow f to 0
while there exists an augmenting path p in the residual network G_f
    augment flow f along p
return f</code></pre><ul>
<li>残存网络<ul>
<li>给定流网络$G$和流量$f$，残存网络$G_f$由那些仍有空间对流量进行调整的边构成。</li>
<li>残存容量定义：</li>
</ul>
</li>
</ul>
<p>$$c_f(u, v) = \begin{cases}<br>c(u,v) - f(u,v), &amp;(u, v)\in E\\<br>f(v,u), &amp;(v, u)\in E\\<br>0, &amp;else<br>\end{cases}<br>$$</p>
<ul>
<li><p>给定一个流网络$G$ 和一个流 $f$，则有$f$ 所诱导的图$G$ 的残存网络为 $G_f = (V, E_f)$，$E_f = {(u,v)\in V \times V: c_f(u, v) &gt; 0}$. 有 $|E_f| \le 2|E|$.  </p>
<ul>
<li>递增</li>
<li>抵消操作</li>
<li>增广路径</li>
</ul>
</li>
<li><p>增广路径p：残存网络 $G_f$中一条从源结点 s 到汇点 t 的简单路径。</p>
</li>
<li><p>残存容量：在一条增广路径p上能够为每条边增加的流量的最大值。</p>
<ul>
<li>流网络的切割</li>
</ul>
</li>
<li><p>流网络的切割：<br>将结点集合$V$ 划分为 $S$ 和 $T = V- S$，</p>
<ul>
<li>横跨切割的净流量 $f(S, T) = \sum_{u \in S}\sum <em>{v \in T}f(u, v) -  \sum</em>{u \in S}\sum _{v \in T}f(v, u)$</li>
<li>切割的容量：$c(S, T) =  \sum_{u \in S}\sum _{v \in T}c(u, v)$</li>
<li>最小切割：整个网络中容量最小的切割</li>
<li>整个流网络的流量与横跨某一个切割的流量相等</li>
</ul>
</li>
<li><p>最大流最小割定理：下列等价：</p>
<ul>
<li><p>$f$ 是 $G$ 的一个最大流。</p>
</li>
<li><p>残存网络 $G_f$ 不包含任何增广路径。</p>
</li>
<li><p>$|f| = c(S, T)$，其中 $(S, T)$ 是流网络 $G$ 中的某个切割</p>
</li>
<li><p>基本的Ford-Fulkerson算法</p>
<p>  FORD-FULEKERSON(G, s, t)<br>  for each edge (u, v) in G.E</p>
<pre><code>(u, v).f = 0</code></pre><p>  while there exists a path p from s to t in the residual network G_f</p>
<pre><code>c_f(p) = min{c_f(u, v)|(u, v) is in p}
for each edge (u, v) in p
    if(u, v) in E
        (u, v).f = (u, v).f + c_f(p)
    else 
        (v, u).f = (v, u).f + c_f(p)</code></pre></li>
</ul>
</li>
</ul>
<h3 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h3><ul>
<li><p>在Ford-Fulkerson算法的第三行使用广度优先搜索来寻找增广路径。<br>每次在残存网络中选择的增广路径是一条从源结点$s$到汇点$t$的最短路径，其中每条边的权重为单位距离。</p>
</li>
<li><p>时间复杂度：$O(VE^2)$</p>
</li>
<li><p>快的原因：使用Edmonds-Karp算法，对于除源结点和汇点外的所有结点 $v$，残存网络 $G_f$ 中的最短路径距离 $\delta f(s,v)$ 随着每次流量的递增而单调递增。</p>
</li>
<li><p>Edmonds-Karp算法所执行的流量递增操作的总次数为 $O(VE)$.</p>
</li>
<li><p>关键边：在残存网络中，一条路径 $p$ 的残存容量是该条路径上边 $(u,v)$ 的残存容量，即 $c_f(p)=c_f(u,v)$.</p>
</li>
<li><p>对于$E$中每条边来说，其成为关键边的次数最多为 $|V|/2$ 次。</p>
</li>
</ul>
<h3 id="dinic算法（oj补充）"><a href="#dinic算法（oj补充）" class="headerlink" title="dinic算法（oj补充）"></a>dinic算法（oj补充）</h3><ul>
<li>通过bfs构造层次网络，然后在层次网络中用dfs进行增广，增广的时候加上条件depth[v] == depth[u] + 1</li>
<li>弧优化：dfs的for循环不从i = Head[u]开始，而从i = Cur[u]，而通过写&amp;i = Cur[u]来实时更新Cur。注意在dinic的外层主循环中要恢复Cur数组。</li>
<li>时间复杂度：$O(V^2E)$</li>
</ul>
<h3 id="最大二分匹配"><a href="#最大二分匹配" class="headerlink" title="最大二分匹配"></a>最大二分匹配</h3><ul>
<li>二分图中，结点划分为不相交的集合 L 和 R，$E$中所有的边都横跨 L 和 R.</li>
<li>构造一个流网络 $G = (V’, E’)$，其中 $V’ = V \cup {s, t}$，$E’ = {(s, u): u\in L} \cup {(u, v): (u, v)\in E} \cup {(v, t): v\in R}$，$E’$中每条边的容量都是 1.</li>
<li>二分图 $G$ 中的一个最大匹配 $M$ 的基数等于其对应的流网络 $G’$ 中某一最大流 $f$ 的值。</li>
<li>时间复杂度：$O(VE)$</li>
</ul>
<h3 id="匈牙利算法（oj补充）"><a href="#匈牙利算法（oj补充）" class="headerlink" title="匈牙利算法（oj补充）"></a>匈牙利算法（oj补充）</h3><ul>
<li>求二部图最大匹配或最小覆盖</li>
<li>在任何一个二分图中，最大匹配中的边数等于最小顶点覆盖中的顶点数。</li>
<li>算法解释：对于每个S中的点，寻找是否有T中的点可以相连；对于T中的点v，如果没有和别的点相连，就连上；如果和S中的u相连，那就看看u能否和别的点相连。</li>
<li>时间复杂度：$O(VE)$</li>
<li>有向无环图的最小路径覆盖：拆点变为二部图，最小路径覆盖 = 顶点数（拆点前） – 最大二分匹配数</li>
<li>无向图的最小路径覆盖=拆点前点的数量-最大匹配数/2</li>
</ul>
<h2 id="其余oj补充部分"><a href="#其余oj补充部分" class="headerlink" title="其余oj补充部分"></a>其余oj补充部分</h2><h3 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h3><p>Tarjan算法</p>
<ul>
<li>可以用来求有向图和无向图中的强\双连通分量，割点和割边</li>
<li>dfn数组记录第一次到达该结点的时间戳</li>
<li>low数组记录该点可以到达的时间戳最小的祖先结点的时间戳</li>
<li>有向图中需要用一个栈保存tarjan遍历的点，一旦dfn[i] = low[i] 就出栈直到点i，这些点就属于同一个强连通分量</li>
<li>常用技巧：缩点<h3 id="图上的游走"><a href="#图上的游走" class="headerlink" title="图上的游走"></a>图上的游走</h3></li>
<li>无向图含欧拉回路&lt;==&gt;全部顶点在同一个连通分量，且度均为偶数</li>
<li>有向图含欧拉迹&lt;==&gt;全部顶点在同一个连通分量，且度均为偶数或有且仅有两个为奇数</li>
<li>有向图含欧拉回路&lt;==&gt;全部顶点在同一个强连通分量，且任意顶点入度等于出度</li>
<li>有向图含欧拉迹&lt;==&gt;全部顶点在底图的同一个连通分量，且 至多一顶点出度=入度+1，至多一顶点出度=入度-1，其余：出度=入度</li>
<li>中国邮递员问题：<ul>
<li>欧拉图走欧拉回路</li>
<li>不是欧拉图则走距离最短的重复路，而走重复路相当于在原图上加边，加权值最小的边使原图变为欧拉图即可</li>
<li>求奇度点之间的最小距离</li>
<li>寻找奇度点的最小权完美匹配</li>
</ul>
</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/问题求解三/" rel="tag"># 问题求解三</a>
          
            <a href="/tags/算法导论/" rel="tag"># 算法导论</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/01/CZ/" rel="next" title="图论定理整理">
                <i class="fa fa-chevron-left"></i> 图论定理整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/01/串匹配/" rel="prev" title="串匹配">
                串匹配 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">XY</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#问题求解3算法导论整理"><span class="nav-number">1.</span> <span class="nav-text">问题求解3算法导论整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">1.1.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最优子结构："><span class="nav-number">1.1.1.</span> <span class="nav-text">最优子结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现："><span class="nav-number">1.1.2.</span> <span class="nav-text">实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重构解"><span class="nav-number">1.1.3.</span> <span class="nav-text">重构解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解题思考过程"><span class="nav-number">1.1.4.</span> <span class="nav-text">解题思考过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例："><span class="nav-number">1.1.5.</span> <span class="nav-text">例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪心"><span class="nav-number">1.2.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最优子结构（同上）"><span class="nav-number">1.2.1.</span> <span class="nav-text">最优子结构（同上）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心选择性质"><span class="nav-number">1.2.2.</span> <span class="nav-text">贪心选择性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法设计步骤"><span class="nav-number">1.2.3.</span> <span class="nav-text">算法设计步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例：-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">1.3.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三个基本操作"><span class="nav-number">1.3.1.</span> <span class="nav-text">三个基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表表示"><span class="nav-number">1.3.2.</span> <span class="nav-text">链表表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单加权合并启发式策略"><span class="nav-number">1.3.3.</span> <span class="nav-text">简单加权合并启发式策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不相交集合森林"><span class="nav-number">1.3.4.</span> <span class="nav-text">不相交集合森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例：-2"><span class="nav-number">1.3.5.</span> <span class="nav-text">例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">1.4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树问题"><span class="nav-number">1.4.1.</span> <span class="nav-text">最小生成树问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的表示和遍历"><span class="nav-number">1.5.</span> <span class="nav-text">图的表示和遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的表示"><span class="nav-number">1.5.1.</span> <span class="nav-text">图的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历"><span class="nav-number">1.5.2.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#广度优先-bfs"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">广度优先 bfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深度优先-dfs"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">深度优先 dfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拓扑排序"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强连通分量"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">强连通分量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单源最短路径算法"><span class="nav-number">1.6.</span> <span class="nav-text">单源最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BELLMAN-FORD算法"><span class="nav-number">1.6.1.</span> <span class="nav-text">BELLMAN-FORD算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有向无环图中的单源最短路径"><span class="nav-number">1.6.2.</span> <span class="nav-text">有向无环图中的单源最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra算法"><span class="nav-number">1.6.3.</span> <span class="nav-text">Dijkstra算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多源最短路径算法"><span class="nav-number">1.7.</span> <span class="nav-text">多源最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“矩阵乘法”"><span class="nav-number">1.7.1.</span> <span class="nav-text">“矩阵乘法”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd-Warshall算法"><span class="nav-number">1.7.2.</span> <span class="nav-text">Floyd-Warshall算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用于稀疏图的Johnson算法"><span class="nav-number">1.7.3.</span> <span class="nav-text">用于稀疏图的Johnson算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大流算法"><span class="nav-number">1.8.</span> <span class="nav-text">最大流算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流网络"><span class="nav-number">1.8.1.</span> <span class="nav-text">流网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流"><span class="nav-number">1.8.2.</span> <span class="nav-text">流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ford-Fulkerson方法"><span class="nav-number">1.8.3.</span> <span class="nav-text">Ford-Fulkerson方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Edmonds-Karp算法"><span class="nav-number">1.8.4.</span> <span class="nav-text">Edmonds-Karp算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dinic算法（oj补充）"><span class="nav-number">1.8.5.</span> <span class="nav-text">dinic算法（oj补充）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大二分匹配"><span class="nav-number">1.8.6.</span> <span class="nav-text">最大二分匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法（oj补充）"><span class="nav-number">1.8.7.</span> <span class="nav-text">匈牙利算法（oj补充）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其余oj补充部分"><span class="nav-number">1.9.</span> <span class="nav-text">其余oj补充部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的连通性"><span class="nav-number">1.9.1.</span> <span class="nav-text">图的连通性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图上的游走"><span class="nav-number">1.9.2.</span> <span class="nav-text">图上的游走</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XY</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
