<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="线程threadspthread_create() 创立线程 pthread_join() 等待某线程结束  线程是操作系统能够进行运算调度的最小单位 进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位  顺序、原子性、可见性的丧失 原子性: 一个操作是不可中断的，要么全部执行成功要么全部执行失败. 即使单处理器, 也会因为操作系统中断而丧失. 顺序性: 如果在">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2019/07/01/os笔记/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="线程threadspthread_create() 创立线程 pthread_join() 等待某线程结束  线程是操作系统能够进行运算调度的最小单位 进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位  顺序、原子性、可见性的丧失 原子性: 一个操作是不可中断的，要么全部执行成功要么全部执行失败. 即使单处理器, 也会因为操作系统中断而丧失. 顺序性: 如果在">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/f1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/f2.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/iodev-model.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/fat32-pbr.jpg">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/FAT32.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/fat32-dirent.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/ext2-inode.gif">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/ext2-groups.png">
<meta property="og:image" content="http://yoursite.com/2019/07/01/figs/callgraph.png">
<meta property="og:updated_time" content="2019-07-01T06:32:06.261Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="线程threadspthread_create() 创立线程 pthread_join() 等待某线程结束  线程是操作系统能够进行运算调度的最小单位 进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位  顺序、原子性、可见性的丧失 原子性: 一个操作是不可中断的，要么全部执行成功要么全部执行失败. 即使单处理器, 也会因为操作系统中断而丧失. 顺序性: 如果在">
<meta name="twitter:image" content="http://yoursite.com/2019/07/01/figs/f1.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/07/01/os笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>操作系统 | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/os笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-01 13:55:30 / Modified: 14:32:06" itemprop="dateCreated datePublished" datetime="2019-07-01T13:55:30+08:00">2019-07-01</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="线程threads"><a href="#线程threads" class="headerlink" title="线程threads"></a>线程threads</h2><p>pthread_create() 创立线程</p>
<p>pthread_join() 等待某线程结束</p>
<ul>
<li><strong>线程</strong>是操作系统能够进行运算调度的最小单位</li>
<li><strong>进程</strong>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</li>
</ul>
<h3 id="顺序、原子性、可见性的丧失"><a href="#顺序、原子性、可见性的丧失" class="headerlink" title="顺序、原子性、可见性的丧失"></a>顺序、原子性、可见性的丧失</h3><ul>
<li><strong>原子性</strong>: 一个操作是不可中断的，要么全部执行成功要么全部执行失败. 即使单处理器, 也会因为操作系统中断而丧失.</li>
<li><strong>顺序性</strong>: 如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的</li>
<li><strong>可见性</strong>: 当一个线程修改了共享变量后，其他线程能够立即得知这个修改. 因为处理器的cache而丧失.</li>
</ul>
<p>因此需要锁.</p>
<h2 id="锁和条件变量的使用"><a href="#锁和条件变量的使用" class="headerlink" title="锁和条件变量的使用"></a>锁和条件变量的使用</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + <span class="number">1</span>; </span><br><span class="line"><span class="comment">// or whatever your critical section is</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有别的线程拥有这把锁, 那么当前线程得到锁, 继续运行;</p>
</li>
<li><p>如果别的线程持有该锁, 那么当前线程将一直等待直到得到锁.</p>
</li>
<li><p>锁初始化:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">assert(rc == <span class="number">0</span>); <span class="comment">// always check success!</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>pthread_cond_wait让线程睡眠, 等待其他线程发出信号</li>
<li>pthread_cond_signal唤醒正在沉睡中的对应线程</li>
<li>初始化: <ul>
<li>pthread_cond_init() </li>
<li>PTHREAD COND INITIALIZER</li>
</ul>
</li>
</ul>
<h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><h3 id="硬件层"><a href="#硬件层" class="headerlink" title="硬件层"></a>硬件层</h3><h4 id="LOCK指令"><a href="#LOCK指令" class="headerlink" title="LOCK指令"></a>LOCK指令</h4><ul>
<li><p>保证顺序, 原子性和可见性</p>
<h4 id="LL-SC"><a href="#LL-SC" class="headerlink" title="LL/SC"></a>LL/SC</h4></li>
<li><p>把一对读-写实现成一对“可能失败”的操作</p>
<ul>
<li><p>Load Linked (LL)：先执行一次读操作，并且在地址上做一个“标记”</p>
</li>
<li><p>Store Conditional (SC)：试探性地写入LL相同的地址(通过对内存地址获得独占访问)。如果LL-SC之间没有其他到该地址的写操作，则写入内存，返回SUCC；否则不执行写入(进而不会污染任何内存)，并返回FAIL。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3></li>
<li><p>开关中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lk)</span> </span>&#123;</span><br><span class="line">    pushcli();</span><br><span class="line">    <span class="keyword">while</span> (atomic_xchg(&amp;lk-&gt;locked, <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lk)</span> </span>&#123;</span><br><span class="line">    atomic_xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br><span class="line">    popsti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意ABBA类型, 不能过早地开中断. 可以将lock和unlock想成入栈和出栈的过程(处理器维护).<h3 id="能睡眠的互斥锁"><a href="#能睡眠的互斥锁" class="headerlink" title="能睡眠的互斥锁"></a>能睡眠的互斥锁</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>取消处理器空转, 在自旋失败的时候切换到别的线程执行</p>
</li>
<li><p>失败时将自己加入等待队列</p>
</li>
<li><p>有人释放锁时唤醒</p>
</li>
<li><p>例子: 游泳池的进入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">  <span class="keyword">int</span> guard; <span class="comment">// 持有guard锁才能更改flag</span></span><br><span class="line">  <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">    m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acqured</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue_add(m-&gt;q, gettid());</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>; <span class="comment">// 解锁</span></span><br><span class="line">    park(); <span class="comment">// 睡眠</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    unpark(queue_remove(m-&gt;q)); <span class="comment">// 唤醒</span></span><br><span class="line">  m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






</li>
</ul>
<h2 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h2><ul>
<li>最简单的做法: 每一个操作都上一把锁.</li>
<li>问题: 性能太差</li>
<li>计数器: 可用近似计数器, 每个CPU分别计数, 到达一个阈值就更新给全局计数器. </li>
<li>链表: 每次list一把大锁; 或者每个结点一把锁</li>
<li>队列: 头和尾各一把锁</li>
</ul>
<h2 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li><p>非常直观的同步方法：一个条件变量代表“某个条件满足”，支持：</p>
<ul>
<li><strong>等待</strong>某个条件满足后发生</li>
<li>某个条件满足，<strong>唤醒一个</strong>正在等待的线程</li>
<li>某个条件满足，<strong>唤醒所有</strong>正在等待的线程</li>
</ul>
</li>
<li><p>pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);<br>pthread_cond_signal(pthread_cond_t *c);唤醒一个</p>
<p>pthread_cond_broadcast(pthread_cond_t *c);唤醒所有</p>
</li>
<li><p><code>wait()</code>函数还需要一个<strong>互斥锁</strong>作为参数。<code>wait()</code>会解开锁并且让调用者进入睡眠状态（这是一个原子操作）。当调用者被唤醒时，<code>wait()</code>必须重新上锁，然后才能返回到调用者。</p>
</li>
<li><p>实现join</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  mutex_lock(&amp;mutex);</span><br><span class="line">  done[id] = <span class="number">1</span>; <span class="comment">// 可能和read并发执行</span></span><br><span class="line">  signal(&amp;joins);</span><br><span class="line">  mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; i++)</span><br><span class="line">    create(worker, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; i++) &#123;</span><br><span class="line">    lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (!done[i]) &#123;</span><br><span class="line">      wait(&amp;joins, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>如果删除了<code>done</code>：子线程先运行，父线程进入睡眠状态，永远无法唤醒。</p>
</li>
<li><p>如果删除了互斥锁：父线程获取数据的同时子线程修改了数据，产生竞争，父线程随即进入睡眠状态，永远无法唤醒。</p>
</li>
</ul>
<ul>
<li><p>注意: <strong>不要先signal再wait</strong></p>
</li>
<li><p>注意: <strong>wait前要上锁!!!</strong></p>
</li>
<li><p>signal建议在解锁之前</p>
</li>
</ul>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><ul>
<li><p>如果用一个信号变量, 会出现2个问题:</p>
<ul>
<li>问题1: 消费者C1因无商品休眠后, 被唤醒时, C2抢先清空了缓冲区, 但C1仍然认为有商品.<ul>
<li>问题关键: 没有确保唤醒了的线程立即执行.</li>
<li>解决方法: 将count的判断由if改为while.</li>
<li>解决的原因: wake up后马上check条件变量是否为1.</li>
<li>启示: 总是用<strong>while</strong>循环来处理条件变量, 多检查一次总是安全的!!!</li>
</ul>
</li>
<li>问题2: 消费者可能会唤醒消费者<ul>
<li>问题关键: 我们需要信号去唤醒线程，但信号的对象必须明确：消费者不能唤醒消费者，只能唤醒生产者，反之亦然。</li>
<li>解决方法: 用两个条件变量</li>
</ul>
</li>
</ul>
</li>
<li><p>生产者和消费者仍然需要支持并发性：需要多个商品缓冲区，可以一次生产/消费多个商品。</p>
</li>
<li><p>虚假唤醒: 反正用while就行.</p>
<p><img src="../figs/f1.png" alt="img"></p>
<p><img src="../figs/f2.png" alt="img"></p>
</li>
</ul>
<h2 id="信号量Semaphores"><a href="#信号量Semaphores" class="headerlink" title="信号量Semaphores"></a>信号量Semaphores</h2><ul>
<li><p>将生产者消费者问题中的互斥锁, 条件变量, 计数器合三为一.</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 第三个参数是初始值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// decrement the value of semaphore s by one</span></span><br><span class="line">  <span class="comment">// wait if value of semaphore s is negative</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// increment the value of semaphore s by one</span></span><br><span class="line">  <span class="comment">// if there are one or more threads waiting, wake one</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>信号量也是一个结构体<code>sem_t</code>，内部包含一个计数器<code>count</code>，它的行为是：</p>
<ul>
<li><p>P(原子)操作时，<code>count</code>减1，如果计数器数值小于零则线程睡眠等待</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> &amp;sem)</span> </span>&#123;</span><br><span class="line">  sem-&gt;count--;</span><br><span class="line">  <span class="keyword">if</span> (sem-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    push(sem-&gt;<span class="built_in">queue</span>, current);</span><br><span class="line">    suspend();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>V(原子)操作时，<code>count</code>加一，同时如果有正在睡眠的线程，则把睡眠的线程唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> &amp;sem)</span> </span>&#123;</span><br><span class="line">  sem-&gt;count++;</span><br><span class="line">  <span class="keyword">if</span> (!empty(sem-&gt;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    wakeup(pop(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>信号量 = 互斥锁 + 条件变量</p>
<ul>
<li>P/V是原子操作</li>
<li>仅有一个手环 = 互斥锁</li>
<li>P = wait; V = signal</li>
<li>因为计数器的存在，不会发生signal“丢失”(先signal再wait)</li>
<li>例子: 游泳池和手环</li>
</ul>
</li>
<li><p>实际上，信号量可以理解成一个锁(手环)的“池子”，计数器就是<strong>锁的数量</strong>。然后把P/V操作直观地理解：</p>
<ul>
<li>P操作就是从池子里取走一把锁。如果取成功，线程继续执行，如果取失败，就必须等待。</li>
<li>V操作就是把一把锁放进池子里。这时候如果有线程在等锁，那个线程可以取走这把锁执行。</li>
</ul>
</li>
<li><p>如果<code>count</code>的初始值为1，我们可以直接把P/V当作互斥锁来使用——池子里只有一把锁，进入临界区必须取得锁，临界区结束后归还。</p>
</li>
<li><p>一个简单的二元信号量锁的实现方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化信号量为1（书本原代码此处为问题）</span></span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量可用于等待其他进程</p>
</li>
<li><p>信号量解生产者消费者问题:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> empty = SEM_INIT(n);</span><br><span class="line"><span class="keyword">sem_t</span> fill = SEM_INIT(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;empty);</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">    V(&amp;fill);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;fill);</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">    V(&amp;empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意生产者消费者问题中的线程安全性. (printf是安全的)</li>
<li>解决方案：先等信号，再上锁。</li>
</ul>
</li>
<li><p>注意: P和V都不能被锁!!! 否则会死锁!!!</p>
</li>
<li><p>读写锁: 当一个线程想要获得第一把读锁时，它同时会获取写锁，直到它结束后才会释放写锁。这样，如果有线程想要获得写锁，就必须等待所有的读线程退出临界区。(性能垃圾)</p>
</li>
</ul>
<h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><ul>
<li>问题所在: 如何防止死锁</li>
<li>解决方案：<ol>
<li>增加一个管理者, 管理所有叉子</li>
<li>所有哲学家都先拿编号大的叉子(破坏环路)</li>
<li>上锁, 每次只有一个哲学家wait</li>
<li>只有拿起两支筷子的哲学家才可以进餐，否则，一支筷子也不拿。</li>
</ol>
</li>
</ul>
<h2 id="并发bugs"><a href="#并发bugs" class="headerlink" title="并发bugs"></a>并发bugs</h2><h3 id="死锁-ABBA"><a href="#死锁-ABBA" class="headerlink" title="死锁 (ABBA)"></a>死锁 (ABBA)</h3><ul>
<li><p>出现线程“互相等待”的情况</p>
</li>
<li><p>可能: spinlock不小心打开中断</p>
</li>
<li><p>死锁最基本的形式 (<strong>ABBA</strong>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1      tread2</span><br><span class="line">lock(A);</span><br><span class="line">             lock(B);</span><br><span class="line"></span><br><span class="line">lock(B); <span class="comment">// 阻塞</span></span><br><span class="line">             lock(A); <span class="comment">// 阻塞</span></span><br><span class="line"><span class="comment">// 任何线程都不能进入临界区</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在一个线程连续的两次lock之间发生另一个lock事件，死锁才会能触发。</p>
</li>
<li><p>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_obj</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  spin_lock(&amp;lock[i]);</span><br><span class="line">  spin_lock(&amp;lock[j]);</span><br><span class="line">  arr[i] = <span class="literal">NULL</span>;</span><br><span class="line">  arr[j] = arr[i];</span><br><span class="line">  spin_unlock(&amp;lock[j]);</span><br><span class="line">  spin_unlock(&amp;lock[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时move_obj(1, 2)<code>;</code>move_obj(2, 1).</p>
</li>
</ul>
</li>
<li><p>死锁产生的四个条件 :</p>
<ul>
<li>互斥：一个资源每次只能被一个进程使用</li>
<li>请求与保持：一个进程请求资源阻塞时，不释放已获得的资源</li>
<li>不剥夺：进程已获得的资源不能强行剥夺</li>
<li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li>
</ul>
</li>
<li><p>AA型死锁非常容易检测</p>
</li>
<li><p>为了避免ABBA型的死锁</p>
<ul>
<li>任意时刻系统中的锁都是有限的</li>
<li>严格按照固定的顺序获得所有锁 </li>
<li>给上锁过程上个大锁</li>
</ul>
</li>
</ul>
<h3 id="原子性违反-ABA"><a href="#原子性违反-ABA" class="headerlink" title="原子性违反 (ABA)"></a>原子性违反 (ABA)</h3><ul>
<li>互斥锁(lock/unlock) - 原子性</li>
<li>忘记上锁——原子性违反 (Atomicity Violation, AV)</li>
</ul>
<h3 id="顺序违反-BA"><a href="#顺序违反-BA" class="headerlink" title="顺序违反 (BA)"></a>顺序违反 (BA)</h3><ul>
<li>条件变量(wait/signal) - 同步</li>
<li>忘记同步——顺序违反 (Order Violation, OV)</li>
<li>常见的情况：use after free</li>
</ul>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><ul>
<li>数据竞争是两个共享内存访问，它们满足以下条件：<ul>
<li>访问同一个共享内存变量</li>
<li>发生在不同的线程</li>
<li>至少有一个是写</li>
</ul>
</li>
</ul>
<h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><ul>
<li>如果程序只完成“计算”的任务而不做任何输入输出，它就可以看成是一个状态机。程序的内存M和寄存器R构成了程序任意时刻的状态(M,R).</li>
<li>进程的机器状态：内存（地址空间）、寄存器（PC、IP、栈指针、帧指针等）、IO信息等。</li>
<li>每个线程有它自己的资源<ul>
<li><code>const char *name</code> - 它的名字</li>
<li><code>_Context context</code> - 保存的寄存器现场</li>
<li><code>char stack[4096]</code> - 堆栈</li>
</ul>
</li>
<li>进程 = 线程 + 地址空间</li>
</ul>
<h3 id="分时复用处理器"><a href="#分时复用处理器" class="headerlink" title="分时复用处理器"></a>分时复用处理器</h3><ul>
<li><p>只要我们能在某一个时刻，<strong>把M和R从处理器上拆下来，换上(M’,R’)</strong>.</p>
</li>
<li><p>把处理器“拆下来”的机制就是中断/系统调用。</p>
</li>
<li><p>操作系统实际从一开始就驻留在内存中，并且配置了中断处理程序的入口地址，一旦进程发生中断/异常/系统调用，操作系统代码就立即接手执行。</p>
</li>
<li><p>每个进程有自己的R, 因此需要寄存器现场的保存.</p>
</li>
</ul>
<h3 id="操作系统：实现虚拟化"><a href="#操作系统：实现虚拟化" class="headerlink" title="操作系统：实现虚拟化"></a>操作系统：实现虚拟化</h3><ul>
<li>现代计算机系统实现虚拟化里最重要的两个想法就是：<ol>
<li>使用虚拟地址空间VM让多个程序共享一个物理内存；</li>
<li>把(M,R)中寄存器现场R当做数据保存，并在寄存器现场R之间切换。</li>
</ol>
</li>
</ul>
<h3 id="管理应用程序有序执行"><a href="#管理应用程序有序执行" class="headerlink" title="管理应用程序有序执行"></a>管理应用程序有序执行</h3><ul>
<li>应用程序(进程)在计算时，没有任何权限访问不属于自己的内存</li>
<li>应用程序想从外界输入/输出任何信息、请求操作系统完成任何功能，都需要通过<strong>系统调用</strong></li>
</ul>
<h3 id="进程管理API"><a href="#进程管理API" class="headerlink" title="进程管理API"></a>进程管理API</h3><ul>
<li><code>fork()</code>:创建一个与当前进程几乎完全相同的进程(同样的地址空间、同样的内存数据)，为了区别新旧进程，父进程(执行<code>fork</code>的进程)返回被创建进程(子进程)的进程号(pid)，而子进程返回0。</li>
<li><code>execve(const char *path, char *argv[], char *envp[])</code>: 在不改变当前进程拥有资源的前提下，“替换”当前进程为<code>path</code>，并且调用<code>main(argc, argv, envp)</code>执行。除了地址空间被完全重建，很多进程拥有的操作系统相关状态都不发生改变：<ol>
<li>进程号(pid)不变；</li>
<li>文件描述符照用；</li>
<li>进程当前目录不变；</li>
<li>访问权限不变；</li>
<li>附属终端不变；</li>
<li>信号掩码不变；</li>
<li>……</li>
</ol>
</li>
<li><code>_exit()</code>结束进程的一生。注意<code>exit()</code>和<code>_exit()</code>是不同的，前者是libc提供的函数，而后者是操作系统提供的系统调用。在libc库中会执行一些额外的操作，例如执行<code>atexit()</code>注册的call backs，以及清空<code>printf</code>的缓冲区。</li>
<li>新建(create)；</li>
<li>销毁(destroy)：主动退出或者被杀死；</li>
<li>等待(wait)：等待进程直到运行结束；</li>
<li>混合操作(miscellaneous control)：睡眠、恢复等；</li>
<li>状态(status)：获得进程状态。</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul>
<li>简单来说，进程可能处于以下三个状态之一：<ul>
<li>Running：进程在处理器上执行指令；</li>
<li>Ready：进程准备执行，但由于某些原因OS决定现在不让它运行；</li>
<li>Blocked：进程此前执行了某些操作，让它在其他事件发生前停止执行。</li>
</ul>
</li>
<li>决定当前执行什么程序是系统调度的任务</li>
</ul>
<h3 id="直接执行限制"><a href="#直接执行限制" class="headerlink" title="直接执行限制"></a>直接执行限制</h3><ul>
<li>内核态和用户态</li>
<li>自陷, 系统调用</li>
<li>进程切换: <ul>
<li>等待系统调用; </li>
<li>利用时钟中断OS接管</li>
</ul>
</li>
<li>保存和恢复上下文</li>
</ul>
<h2 id="终端和Shell"><a href="#终端和Shell" class="headerlink" title="终端和Shell"></a>终端和Shell</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>File descriptor: 一个操作系统中打开的文件 (一个指向操作系统内对象的“指针”)<ul>
<li>stdin: 0, stdout: 1, stderr: 2</li>
<li><code>open()</code>会返回没有被占用的第一个文件描述符</li>
<li><code>int dup(int oldfd);</code> - 复制<code>oldfd</code></li>
<li><code>int dup2(int oldfd, int newfd);</code> - 关闭<code>newfd</code>，并复制<code>oldfd</code>到<code>newfd</code></li>
</ul>
</li>
</ul>
<h3 id="管道：进程间通信"><a href="#管道：进程间通信" class="headerlink" title="管道：进程间通信"></a>管道：进程间通信</h3><ul>
<li><p>lhs-cmd | rhs-cmd<code>: 运行</code>lhs-cmd<code>，把stdout连接到</code>rhs-cmd的stdin</p>
<ul>
<li><code>int pipe(int pipefd[2]);</code> 在操作系统中创建一个管道</li>
<li><code>pipefd[0]</code> - 读口；<code>pipefd[1]</code> - 写口</li>
</ul>
</li>
<li><p>默认情况下，管道是有限大小、blocking的</p>
<ul>
<li>管道满，write将等管道空出数据</li>
<li>管道空，read将等数据</li>
</ul>
</li>
<li><p><code>fork()</code> 不复制管道</p>
</li>
<li><p>Shell的主要功能是将执行命令的脚本翻译成系统调用的序列</p>
<ul>
<li><code>cmd &gt; file &lt; file</code> - 使用<code>fork-open-dup-execve</code></li>
<li><code>cmd1; cmd2</code>, <code>cmd1 &amp;&amp; cmd2</code>, <code>cmd1 || cmd2</code> - 按顺序执行</li>
<li><code>cmd1 | cmd2</code> - 使用<code>pipe-fork-dup-execve</code></li>
<li>预处理：<code>$()</code> - 创建一个shell，将输出重定向到管道中读出</li>
</ul>
</li>
</ul>
<h3 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h3><ul>
<li><p>在应用层实现的中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在程序执行到一半时“跳转”到某个函数执行</p>
</li>
<li><p>接收到Ctrl-C的终端驱动程序会给终端对应的<strong>进程组</strong>发送 <strong>SIGINT</strong></p>
<p>(所有进程都会收到)</p>
<ul>
<li>Shell也可以选择使用raw mode，读取Ctrl-C，然后使用<code>kill()</code>发送<code>SIGINT</code></li>
<li>此时shell还需要把其他输入转发给jobs (tmux的实现)</li>
</ul>
</li>
<li><p>Shell关闭时</p>
<ul>
<li>给所有jobs发送<code>SIGHUP</code> (hang up)，默认行为是结束进程</li>
<li>nohup就是忽略这个信号</li>
</ul>
</li>
</ul>
<h3 id="输出到终端和重定向到文件的区别"><a href="#输出到终端和重定向到文件的区别" class="headerlink" title="输出到终端和重定向到文件的区别"></a>输出到终端和重定向到文件的区别</h3><ul>
<li><p>输出到终端, 输出条件为: </p>
<ul>
<li>满1024字节/换行/程序结束/手动fflush/stdin的scanf</li>
</ul>
</li>
<li><p>输出重定向到文件, 输出条件为:</p>
<ul>
<li>程序结束</li>
</ul>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li><p><strong>周转时间</strong> turnaround time: </p>
<p>$$ T_{turnaround} = T_{completion} - T_{arrival}$$</p>
</li>
<li><p>First In, First Out(FIFO)</p>
<ul>
<li>在任务所需时间不同的时候效果很差</li>
<li>护卫效应(convoy effect)</li>
</ul>
</li>
<li><p>Shortest Job First (SJF)</p>
<ul>
<li>在长的任务先来的时候还是有很差</li>
</ul>
</li>
<li><p>Shortest Time-to-Completion First (STCF)</p>
<ul>
<li>每当新任务到来, 判断谁先完成, 调度最先完成的那个</li>
</ul>
</li>
<li><p><strong>响应时间</strong>response time:</p>
<p>$$T_{response} = T_{firstrun} − T_{arrival}$$</p>
</li>
<li><p>Round Robin (Good For Response Time)</p>
<ul>
<li>时间片time slice</li>
<li>每次花一段时间(time slice/scheduling quantum)执行一个任务，然后切换到队列的下一个任务。</li>
</ul>
</li>
<li><p>Incorporating I/O</p>
<ul>
<li>任务执行I/O操作时会被阻塞，直到I/O操作完成。如果进行硬件读写，就可能会导致几毫秒的等待。因此，调度算法必须在I/O操作出现时合理的切换到别的任务。</li>
<li>当I/O操作完成时，会产生硬件中断，此时OS接管并将发起请求的进程调回ready状态。</li>
</ul>
</li>
<li><p>Multi-level Feed-back Queue (MLFQ):</p>
<ul>
<li><p>2条规则: </p>
<ul>
<li><p>规则1: 如果A比B优先级高,就跑A</p>
</li>
<li><p>规则2: 如果AB优先级相同, 用RR</p>
</li>
</ul>
</li>
<li><p>优先级改变:</p>
<ul>
<li><p>规则3: 一个任务刚进入系统, 则最高优先级</p>
</li>
<li><p>规则4a: 一个任务用完了一整个时间片, 则降低优先级</p>
</li>
<li><p>规则4b: 一个任务在时间片用完之前放弃了CPU, 则优先级不变</p>
</li>
</ul>
</li>
<li><p>避免starvation:</p>
<ul>
<li>问题1：如果系统中有太多交互型的程序，他们的优先级高，会保持对CPU的占用，那么低优先级的程序就永远无法得到CPU时间(starve)</li>
<li>问题2: 进程的行为可能随时间改变，一个计算型程序可能会变为交互型程序。此时这个程序无法重新获得优先级，响应时间高。</li>
<li>规则5: 经过一段时间S, 系统中所有任务优先级提到最高</li>
</ul>
</li>
<li><p>避免用户恶意利用调度规则</p>
<ul>
<li>问题: 恶心人的用户会破坏调度算法的合理性(game the scheduler)，在时间截止前进程发起一个（不关心结果的）I/O请求来放弃CPU，就可以保持在同一个优先级队列中，获得更多的CPU时间。</li>
<li>改写规则4: 一旦一个任务用完了某个等级分配的所有时间, 优先级就降低.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Proportional-Share"><a href="#Proportional-Share" class="headerlink" title="Proportional Share"></a>Proportional Share</h2><ul>
<li><p>每个进程都有一定的tickets(彩票), 彩票越多中奖率越高, 用随机数来选择调度哪一个(中奖)</p>
</li>
<li><p>ticket currency: </p>
<ul>
<li>每个user给自己的进程发tickets, 按比例兑换成global ticket</li>
</ul>
</li>
<li><p>ticket transfer:</p>
<ul>
<li>一个进程暂时把自己的tickets给另一个进程</li>
<li>尤其出现于 client/server</li>
</ul>
</li>
<li><p>ticket inflation:</p>
<ul>
<li>一个进程可以暂时增加或者减少自己的彩票数.</li>
<li>仅适用于互相信任的进程之间</li>
</ul>
</li>
<li><p>stride scheduling: </p>
<ul>
<li>确定的.</li>
<li>不好, 因为有global state. 当一个新进程进入的时候，pass的初始值决定了它是否能够霸占CPU；而在彩票方法中，添加一个新进程并不会影响其他进程的执行。彩票方法更容易处理新的进程。</li>
</ul>
</li>
</ul>
<h3 id="The-Linux-Completely-Fair-Scheduler-CFS"><a href="#The-Linux-Completely-Fair-Scheduler-CFS" class="headerlink" title="The Linux Completely Fair Scheduler (CFS)"></a>The Linux Completely Fair Scheduler (CFS)</h3><ul>
<li><p>引入了<strong>virtual runtime(vruntime)</strong></p>
</li>
<li><p>进程运行的时候增加vruntime</p>
</li>
<li><p>每次选择vruntime最低的</p>
</li>
<li><p>切换进程的时间选择:</p>
<ul>
<li>sched_latency(48 ms): <ul>
<li>决定多久后考虑是否要切换</li>
<li>这个值 / 进程数 决定时间片的长度</li>
<li>进程过多会导致时间片太小</li>
</ul>
</li>
<li>min_granularity(6 ms):<ul>
<li>最小时间片长度</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Weighting (Niceness)</strong></p>
<ul>
<li>UNIX世界允许用户调整进程的优先级(nice)<ul>
<li>-20 (最高优先级)：非常不nice (是个坏人)</li>
<li>19 (最低优先级)：非常nice (是个礼让的好人)</li>
</ul>
</li>
<li>时间片长度按照weight加权</li>
<li>vruntime 增加速度和weight相关, weight越大, 时间流逝越慢.</li>
</ul>
</li>
<li><p>红黑树来了, 飘过</p>
</li>
<li><p>I / O 处理和长时间睡眠进程: 进程醒了以后, vruntime最小为运行进程的最小vruntime减一个定值</p>
</li>
</ul>
<h3 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h3><ul>
<li>进程是属于处理器的，只被某个处理器调度(最大化cache locality)</li>
<li>只有在workload imbalance的时候，才进行cross-core migration</li>
<li>Scheduling threads on a multicore machine is hard</li>
</ul>
<h2 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h2><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><ul>
<li>是一个函数 $f(x) \in [0,M)$<ul>
<li>把地址空间中的任何一个地址映射到另一个地址</li>
<li>任何指令访问地址 x (包括取指令)，经过地址翻译后访问 f(x)</li>
<li>访问未映射的页面 $f(x)=\bot$ 将会触发异常 (Segmentation Fault)</li>
</ul>
</li>
</ul>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ul>
<li><p>段 (segment)：仅允许几段连续的虚拟内存</p>
<ul>
<li>x86: GDT, LDT描述“段”的内存映射</li>
</ul>
</li>
<li><p>就是虚拟内存分成一个个段, 比如堆区, 栈, 代码, 分别映射到物理内存中的一段区域</p>
</li>
</ul>
<h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><ul>
<li>主要介绍free list:<ul>
<li>内存区域里面, 每一块空闲内存头上存着size和next, 已分配区域存size和魔数magic</li>
<li>malloc就是在free list中找到一块适宜的, 标记为已经分配</li>
<li>free就是将一块内存重新连回free list之中</li>
<li>malloc的时候有分裂, free的时候有合并</li>
</ul>
</li>
<li>buddy system:<ul>
<li>每一块内存都是2的幂次大小, 用线段树存</li>
</ul>
</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li><p>页 (page)：可以以页为单位自由映射</p>
<ul>
<li>x86: “页目录-页表”数据结构描述内存映射</li>
<li>内存越大，页表层数越多：PML4 (48bit)</li>
</ul>
</li>
<li><p>复习：</p>
<ul>
<li>MMU</li>
<li>多级页表</li>
<li>反置页表IPT<ul>
<li>我们实际希望的是在系统中创造多个地址空间$as$，并且维护$f_{as}(x)$</li>
<li>我们不如让硬件维护一个全局的hash table，计算$f(as, x)$</li>
</ul>
</li>
<li>TLB (Translation Lookaside Buffer); </li>
<li>page table entry (PTE)</li>
<li>physical page number(PPN), virtual page number(VPN)</li>
<li>valid bit, protection bit, present bit, dirty bit, reference bit</li>
</ul>
</li>
</ul>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><ul>
<li><p>操作系统应该如何为进程提供虚拟内存管理？因为<em>Everything is a File</em>，所以只要能把操作系统里的对象“映射”到进程地址空间，就足够了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">// 映射</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot)</span></span>; <span class="comment">// 修改映射权限</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将文件fd从offset开始的length长度映射到进程地址空间中虚拟地址addr开始的部分</li>
<li>如果addr == NULL, os选一个地址</li>
<li>prot: 是否可读, 可写, 可执行</li>
<li>flags: 是否可共享, …</li>
<li>成功则返回指向映射区域的一个指针, 失败则返回(void *) -1.</li>
</ul>
</li>
<li><p>不映射任何文件(<code>fd=-1</code>, <code>MAP_ANONYMOUS</code>)，等同于内存分配 (<code>mmap</code>可以直接分配几十GB的内存；用户空间的内存分配是基于mmap实现的)</p>
</li>
<li><p>可以映射任何支持mmap的文件/设备</p>
<ul>
<li>ELF文件中间的那么多“空白”: 为了填满一页</li>
</ul>
</li>
<li><p>可以以各种权限(<code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code>)映射</p>
</li>
<li><p>操作系统会管理好一切(偶尔你需要<code>msync (2)</code>)</p>
</li>
<li><p>mmap并不需要真的映射</p>
<ul>
<li>操作系统只需要记下这一次mmap操作，并将页面标记为“不存在”</li>
<li>缺页时操作系统就“知道”该给这个页面填入什么值<ul>
<li>找到映射的文件</li>
<li>如果没有文件，直接返回一个全0的页面</li>
<li>如果有文件，从文件处读取数值</li>
<li>msync或页面回收时写回文件</li>
</ul>
</li>
<li>我们允许进程使用的内存大于物理内存</li>
<li>只要有一个大容量的设备，在物理内存紧缺时，swap out一些不常用的物理页(思考题：换出哪一页？)</li>
<li>缺页时再从设备换回</li>
</ul>
</li>
</ul>
<h3 id="fork-写时复制"><a href="#fork-写时复制" class="headerlink" title="fork: 写时复制"></a>fork: 写时复制</h3><ul>
<li>fork并不需要复制完整的<em>M</em></li>
<li>让父子进程只读共享所有页面；写时复制一份</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>它本质上就是个整数</li>
<li>在指针背后，实际是进程的“地址空间”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> value;</span><br><span class="line">*(<span class="keyword">char</span> *)value <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>value = 0</code> -&gt; Segmentation Fault</li>
<li>代码：只读、可执行</li>
<li>数据/堆栈：可读、可写、不可执行</li>
</ul>
<h3 id="静态链接程序的地址空间"><a href="#静态链接程序的地址空间" class="headerlink" title="静态链接程序的地址空间"></a>静态链接程序的地址空间</h3><ul>
<li><p>pmap查看</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00400000-004b6000                 r-xp  /tmp/a.out (代码)</span><br><span class="line">006b6000-006bc000                 rw-p  /tmp/a.out (数据)</span><br><span class="line">006bc000-006bd000                 rw-p  [bss](通过end查证)</span><br><span class="line">0131f000-01342000                 rw-p  [heap]</span><br><span class="line">7fff993c9000-7fff993ea000         rw-p  [stack]</span><br><span class="line">7fff993f4000-7fff993f7000         r--p  [vvar] </span><br><span class="line">7fff993f7000-7fff993f9000         r-xp  [vdso] </span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp  [vsyscall]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Virtual System Call: 系统调用，但不需要<code>int $0x80</code>/<code>sysenter</code></p>
<ul>
<li>gettimeofday/time</li>
<li>getcpu</li>
</ul>
<p>以上系统调用可以在只读内核数据的基础上实现</p>
<ul>
<li>时间：内核维护中断时的时间，用户程序加上rdtsc的结果</li>
<li>getcpu：为每个CPU上的进程映射不同的页面</li>
</ul>
</li>
<li><p>vvar, vdso: 加强版用户空间系统调用</p>
<ul>
<li>vvar: 3 pages (ro, 内核数据); vdso: 2 pages (rx, 统调用代码)</li>
<li>基本等于vsyscall</li>
<li>注意到它们的地址是紧接着堆栈的 (随机值)</li>
</ul>
</li>
</ul>
<h3 id="动态链接程序的地址空间"><a href="#动态链接程序的地址空间" class="headerlink" title="动态链接程序的地址空间"></a>动态链接程序的地址空间</h3><ul>
<li>启动动态链接器</li>
<li>装载所有需要的共享对象</li>
<li>重定位和初始化</li>
<li>ELF中入口点就是动态链接器</li>
<li>动态链接复习: GOT, PLT, …</li>
</ul>
<h2 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h2><h3 id="Hello-World的故事"><a href="#Hello-World的故事" class="headerlink" title="Hello World的故事:"></a>Hello World的故事:</h3><ul>
<li><p>Hello World的一生是从execve()开始的</p>
<ul>
<li>继承父进程的文件描述符(<code>./a.out &gt; /dev/null</code>; <code>./.a.out | cat</code>, …)</li>
<li>内核会为<code>a.out</code>创建代码、数据、堆栈</li>
</ul>
</li>
<li><p>执行的第一条指令</p>
<ul>
<li>从ELF的entry开始执行<ul>
<li>静态链接：<code>a.out</code>的entry</li>
<li>动态链接：<code>ld.so</code>的entry (动态链接器)</li>
<li>动态链接libc：链接器使用一系列mmap把libc链接进进程地址空间</li>
</ul>
</li>
</ul>
</li>
<li><p>main() 执行之前</p>
<ul>
<li><code>ld.so</code>会调用<code>_init()</code>；之后会调用<code>_start</code>, <code>__libc_start_main</code>, …<ul>
<li>但都是普通的“用户代码”，libc也是一个普通的C程序</li>
<li>完成整个C runtime的初始化，其中可能调用系统调用<ul>
<li>一个有趣的系统调用: ioctl, 判断是否是tty</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>main()的执行</p>
<ul>
<li>printf(…)<ul>
<li>如果有缓冲区，写入缓冲区 (fork会复制缓冲区)，否则直接用write写入<code>STDOUT_FILENO</code></li>
<li>如果缓冲区满足flush条件，则用write写入</li>
</ul>
</li>
</ul>
</li>
<li><p>main执行结束后，libc代码依然会执行(exit()也进行这些操作)</p>
<ul>
<li>调用<code>atexit()</code>注册的回调函数</li>
<li>清空缓冲区、释放资源</li>
<li>执行<code>_exit()</code>退出</li>
<li>如果结束前调用了_exit(), 则直接结束, 不进行上述操作</li>
</ul>
</li>
</ul>
<h3 id="进程-操作系统视角"><a href="#进程-操作系统视角" class="headerlink" title="进程: 操作系统视角"></a>进程: 操作系统视角</h3><ul>
<li>操作系统就是个中断处理程序<ul>
<li>系统启动时完成初始化</li>
<li>然后等待中断到来(打开中断，死循环或<code>yield()</code></li>
<li>在中断返回时，精心设计一个进程的上下文(context)<ul>
<li>在CR3寄存器中配置好虚拟内存的地址映射和权限</li>
<li>设置好寄存器的值：CS:EIP; SS:ESIP; …</li>
<li>执行<code>iret</code>让进程暂时占有CPU执行</li>
</ul>
</li>
</ul>
</li>
<li>“进程”只是操作系统中的一些数据，操作系统代码维护了代表“进程”的对象，以及和进程相关的对象<ul>
<li>进程上下文(寄存器的数值)</li>
<li>文件描述符(指向操作系统内对象的指针；文件访问的偏移量)</li>
<li>内存映射区域</li>
<li>进程的地址空间(页表、地址空间中的页面)</li>
</ul>
</li>
</ul>
<h3 id="重新理解系统调用"><a href="#重新理解系统调用" class="headerlink" title="重新理解系统调用"></a>重新理解系统调用</h3><ul>
<li><p>操作系统为用户进程提供的一组API，通常在内核空间中实现，实现用户进程对操作系统对象/物理硬件访问的请求。</p>
</li>
<li><p>在刚才的视角上理解系统调用</p>
<ul>
<li>进程 = 操作系统中的数据</li>
<li>系统调用 = 这些数据上的操作</li>
<li>例子：write()向某个操作系统的对象写入数据</li>
<li>例子：mmap()创建一个映射区域</li>
</ul>
</li>
<li><p>文件访问的偏移量问题:</p>
<ul>
<li>系统中所有以O_APPEND的文件描述符共享一个offset</li>
<li>每次单独的open都有一个独立的offset</li>
<li>fork()后父子进程在复制的文件描述符上共享一个offset</li>
</ul>
</li>
</ul>
<h3 id="操作系统与并发"><a href="#操作系统与并发" class="headerlink" title="操作系统与并发"></a>操作系统与并发</h3><ul>
<li>操作系统中的对象是在处理器之间共享的</li>
<li>多处理器系统：原子性、顺序、可见性的丧失</li>
<li>系统调用执行需要协调系统中的各个部分<ul>
<li>例子：read()管道时，需要等数据；write()管道时，需要等待管道的空位，否则阻塞</li>
<li>例子：read()终端时，需要等缓冲区中的数据；按下按键时，向缓冲区中写入数据</li>
<li>例子：使用DMA完成磁盘I/O，等待DMA中断的到来</li>
</ul>
</li>
<li>操作系统中有大量的同步问题<ul>
<li>条件变量</li>
<li>信号量</li>
</ul>
</li>
</ul>
<h2 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h2><ul>
<li>磁: 磁铁方向, 磁盘</li>
<li>光: 挖坑填坑, 光盘</li>
<li>电: SSD</li>
<li>存储介质相当于是一个字节数组<code>bool bits[CAPACITY];</code></li>
</ul>
<h2 id="I-O设备与驱动"><a href="#I-O设备与驱动" class="headerlink" title="I/O设备与驱动"></a>I/O设备与驱动</h2><ul>
<li>I/O设备: 设备是三种操作的集合: <ul>
<li>(别人)发送命令(给他)、(别人)读取(他的)状态、(互相)传输数据</li>
</ul>
</li>
</ul>
<p><img src="../figs/iodev-model.png" alt="iodev-model"></p>
<ul>
<li><p>键盘: 按键信息会存储到键盘内置的缓冲数据区</p>
<ul>
<li><p>缓冲区通常大小是有限的</p>
</li>
<li><p>如果缓冲区满，后续按键将会丢失 (可能会发出声音)</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status = inb(<span class="number">0x64</span>);</span><br><span class="line"><span class="keyword">if</span> ((status &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// no input</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (status &amp; <span class="number">0x20</span>) &#123; <span class="comment">// mouse</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> code = inb(<span class="number">0x60</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// 按键的“扫描码”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>磁盘: 磁盘是一个巨大的bit array</p>
<ul>
<li><p>磁盘控制器: 配置好需要读/写的位置，然后开始传送数据</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">while</span> ((in_byte(<span class="number">0x1F7</span>)&amp;<span class="number">0xC0</span>) != <span class="number">0x40</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span> *dst, <span class="keyword">int</span> sect)</span> </span>&#123;</span><br><span class="line">  waitdisk();</span><br><span class="line">  out_byte(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// 读sector的数量</span></span><br><span class="line">  out_byte(<span class="number">0x1F3</span>, sect);</span><br><span class="line">  out_byte(<span class="number">0x1F4</span>, sect &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  out_byte(<span class="number">0x1F5</span>, sect &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  out_byte(<span class="number">0x1F6</span>, (sect &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">  out_byte(<span class="number">0x1F7</span>, <span class="number">0x20</span>);</span><br><span class="line">  waitdisk();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SECTSIZE / <span class="number">4</span>; i ++)</span><br><span class="line">    ((<span class="keyword">uint32_t</span> *)dst)[i] = in_long(<span class="number">0x1F0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>I/O设备: 实现</p>
<ul>
<li>CPU终究是通过地址和数据访问I/O设备的<ul>
<li>Port IO/MMIO只是两种不同的地址空间</li>
<li>电路负责根据地址把地址和数据“转发”给设备</li>
</ul>
</li>
</ul>
</li>
<li><p>显示加速器(显卡GPU)</p>
<ul>
<li>GPU是一个“协处理器”<ul>
<li>CPU可以将代码和数据传输给GPU</li>
<li>GPU执行程序，并且可以将程序的一部分输出绘制到屏幕上</li>
</ul>
</li>
</ul>
</li>
<li><p>管理I/O设备</p>
<ul>
<li>cat /proc/iomem: 得到IO的内存映射</li>
<li>lspci: 查看总线上的设备</li>
<li>lsblk: 查看块设备</li>
<li>“回路”设备<ul>
<li>可以把一个文件模拟成一个块设备</li>
<li>mount后在lsblk中可以看到</li>
</ul>
</li>
<li>用代码访问I/O设备：<ul>
<li>等待设备空闲</li>
<li>给设备发送数据和命令</li>
<li>等待设备完成命令</li>
</ul>
</li>
<li>拒绝忙等待: 利用中断机制<ul>
<li>在设备完成请求/发生变化时通知处理器</li>
<li>例子：磁盘可以配置成“命令完成后发送中断”</li>
<li>例子：再也不需要轮询键盘，有按键按下后会收到键盘中断</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象层: <strong>设备驱动</strong>(以Lab2为例)</p>
<ul>
<li><p>设备驱动: os中负责与设备交互的程序. 根据设备类型不同, 给每一类设备以统一的接口访问, 实现这个接口的就是设备驱动程序.</p>
</li>
<li><p>从系统启动后就一直存在</p>
</li>
<li><p>简化了很多(Plug and Play非常麻烦)</p>
</li>
<li><p>每个设备有三个操作：初始化、读、写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">device_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">devops</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> (*init)(<span class="keyword">device_t</span> *dev);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read)(<span class="keyword">device_t</span> *dev, <span class="keyword">off_t</span> offset, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write)(<span class="keyword">device_t</span> *dev, <span class="keyword">off_t</span> offset, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125; <span class="keyword">devops_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*init)();</span><br><span class="line">&#125; MODULE(dev);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>DMA：可以理解为实现<code>memcpy()</code>的I/O设备</p>
</li>
<li><p>性能不够, 处理器来凑</p>
</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h3><ul>
<li><p><strong>磁盘</strong> (I/O设备)：一个可以读/写的定长字节序列</p>
<ul>
<li>虚拟磁盘(文件)：一个可以读/写/的动态字节序列</li>
<li>可以理解成<code>std::vector&lt;uint8_t&gt;</code></li>
<li>类比<ul>
<li>进程 (虚拟CPU)：分时共享一个CPU</li>
<li>虚拟存储：多个虚拟地址空间</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件</strong>: 理解成一个名为xxx的<strong>虚拟存储设备</strong>(磁盘)，我们可以对这个虚拟磁盘中执行写入数据、扩展大小等操作</p>
</li>
<li><p><strong>目录directory</strong>: 文件/目录的集合</p>
<ul>
<li>目录体现了局部性：相关的数据存放在相近的目录</li>
<li>目录结构: 树形结构有助于帮我们分组<ul>
<li>人工训练的一个“决策树”</li>
<li>每个目录有<code>.</code> (当前目录)和<code>..</code> (上级目录)两个特殊的目录</li>
</ul>
</li>
</ul>
</li>
<li><p>目录/文件(inode)</p>
<ul>
<li>inode number: 索引数</li>
</ul>
</li>
<li><p><strong>文件系统</strong>是保存在持久存储上的数据结构</p>
<ul>
<li>数据结构在磁盘上的存储格式规范</li>
<li>允许对数据结构进行的操作</li>
<li>文件系统实现 = 数据结构的查询/修改操作<ul>
<li>可以通过文件管理进程(能够访问存储设备)实现</li>
</ul>
</li>
<li>文件系统基本操作<ul>
<li>目录操作：<ul>
<li>改变进程工作目录(chdir)、路径解析(当前目录pwd)</li>
<li>读取目录 (getdents)</li>
<li>目录操作 (link, unlink, rename, …)</li>
</ul>
</li>
<li>文件操作：<ul>
<li>打开(返回文件描述符)、关闭</li>
<li>文件描述符操作：read, write, lseek, ioctl, mmap, …</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件意义扩展: 操作系统中的一个可读/写/控制的<strong>对象</strong></p>
<ul>
<li>文件描述符：指向操作系统对象的handle(指向对象的指针)</li>
<li>read/write/ioctl系统调用 = 对象访问</li>
</ul>
</li>
<li><p><strong>虚拟文件系统</strong></p>
<ul>
<li>需要实现的需求:<ul>
<li>根据路径解析出操作系统中的对象 (磁盘文件、进程、操作系统配置、……)</li>
<li>open() → 解析路径、找到对象 → 对象自带read/write/…操作 → 创建文件描述符</li>
</ul>
</li>
<li>实现:<ul>
<li>把read/write翻译成对操作系统对象的读写, 包括进程/线程, 文件/目录, 设备, 其他数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><ul>
<li><p>procfs, sysfs都不是系统启动自带的，而是“<strong>挂载</strong>”的</p>
<ul>
<li>系统启动后仅有<code>/</code>, <code>/dev</code>，以及initramfs中的少量文件</li>
<li>init程序负责挂载其他部分(例如<code>/home</code>)</li>
</ul>
</li>
<li><p>挂载机制创建了文件系统世界：连接设备 - 文件系统实现 - 目录树</p>
<ul>
<li><code>mount -t type device dir</code></li>
</ul>
</li>
<li><p>系统中允许</p>
<ul>
<li>有多个文件系统根“/”，互相不可见<ul>
<li>chroot; 容器 (namespaces)<ul>
<li>chroot只影响路径解析, 如果持有外部文件描述符，则很容易jail break</li>
<li>如果“everything is a file”，所有可见的东西都在文件系统里，那么改变文件系统root就实现了完全的隔离</li>
</ul>
</li>
</ul>
</li>
<li>一份文件系统代码，多个设备/挂载点<ul>
<li>允许系统内有多个ext4分区</li>
<li>挂载多个procfs/sysfs (容器)</li>
</ul>
</li>
<li>把一个文件(例如.iso)挂载到文件系统中<ul>
<li>通过loopback device (类似于“虚拟光驱”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ul>
<li>目录也存储数据 (字节序列)，也是虚拟磁盘，因此目录和文件都用“inode”表示 (一个编号)</li>
<li>操作系统在路径解析、目录遍历时对它的数据有特殊的解读</li>
<li>实现方法：目录上有一些额外的操作<ul>
<li>lookup (路径解析)</li>
<li>create (创建文件)</li>
<li>link (链接)</li>
<li>unlink (删除)</li>
</ul>
</li>
<li>目录: 并不是树!</li>
<li>Linux系统允许创建两种类型的<strong>链接</strong><ul>
<li>硬链接：hard link<ul>
<li>目标只能是文件, 不能是目录</li>
<li>不能跨文件系统<ul>
<li>硬链接总是合法可以访问——能看到硬链接，说明文件系统被挂载</li>
</ul>
</li>
</ul>
</li>
<li>软(符号)链接：soft/symbolic link<ul>
<li>符号链接可以是任何相对/绝对路径<ul>
<li>只是一个“路径解析提示”</li>
<li>非常有用 &amp; 容易滥用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件管理：打开文件"><a href="#文件管理：打开文件" class="headerlink" title="文件管理：打开文件"></a>文件管理：打开文件</h3><ul>
<li>我们熟知的一系列API，访问各种文件：<ul>
<li>open(); read/write(); close();</li>
</ul>
</li>
<li>用这套API：<ul>
<li>访问磁盘上的数据</li>
<li>读取系统信息 (procfs)</li>
<li>配置操作系统 (sysfs)</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="打开目录"><a href="#打开目录" class="headerlink" title="打开目录"></a>打开目录</h3><ul>
<li>目录可以open但是不能read write</li>
<li>打开目录得到了一个指向文件系统某个位置的指针</li>
<li>对目录本身的操作<ul>
<li>fchmod, fchown, …</li>
</ul>
</li>
<li>相对于目录位置的操作<ul>
<li>openat()</li>
<li>linkat()</li>
</ul>
</li>
<li>更多的好处<ul>
<li>避免了每次open都解析路径 (有时路径很长)</li>
<li>在fd在合法的前提下，目录总是存在</li>
</ul>
</li>
</ul>
<h3 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li><p>对同一个文件的多次操作是自然的</p>
<ul>
<li>文件描述符避免了每次操作都要重新打开文件</li>
<li>同时也帮助我们自动管理文件访问的偏移量</li>
</ul>
</li>
<li><p>内存映射方式访问</p>
<ul>
<li>适合随机访问的结构数据 (数据库)</li>
<li>mmap</li>
</ul>
</li>
<li><p>或read/write方式访问</p>
<ul>
<li>适合流式文件 (文件描述符托管了offset)</li>
</ul>
</li>
</ul>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul>
<li>执行<code>sync</code>命令, 将缓存中磁盘操作都写入磁盘</li>
</ul>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><ul>
<li>文件系统是支持文件和目录操作的数据结构<ul>
<li>文件实现磁盘的虚拟化</li>
<li>目录实现文件的分类归档</li>
</ul>
</li>
</ul>
<h3 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h3><ul>
<li><p>块设备 = 固定大小的块(block)的数组 (存储设备)；支持：</p>
<ul>
<li>read(#blk, data)</li>
<li>write(#blk, data)</li>
<li>查看块大小<code>blockdev --getbsz /dev/sda2</code> (通常4KB) (通过sysfs得知)</li>
</ul>
</li>
<li><p>块设备API:</p>
<ul>
<li>进程/线程(通常是文件系统实现)向存储设备提交I/O request (block读/写)<ul>
<li>request首先进入设备的队列</li>
<li>经过调度器调度后，执行设备上的I/O (DMA)</li>
</ul>
</li>
<li>调度是为了<ul>
<li>保证多进程之间的公平性/优先级</li>
<li>I/O操作的合并</li>
</ul>
</li>
</ul>
</li>
<li><p>Block I/O调度</p>
<ul>
<li>I/O请求优化 + 兼顾进程优先级和公平<ul>
<li>例子：按照“电梯”方式寻道</li>
</ul>
</li>
<li>不该归操作系统管</li>
</ul>
</li>
</ul>
<h3 id="实现文件系统1-虚拟磁盘"><a href="#实现文件系统1-虚拟磁盘" class="headerlink" title="实现文件系统1: 虚拟磁盘"></a>实现文件系统1: 虚拟磁盘</h3><ul>
<li><p>文件 = 虚拟的磁盘</p>
<ul>
<li>数据块的数组，支持read, write, lseek操作</li>
<li>元数据 (大小固定)：大小、访问权限、修改时间……</li>
</ul>
</li>
<li><p>链表或树实现:</p>
<ul>
<li>只需要balloc()和bfree()</li>
</ul>
</li>
<li><p>在磁盘里划分一块专门的区域，每个bit代表每个块是否可用</p>
</li>
</ul>
<h3 id="实现文件系统2-目录文件"><a href="#实现文件系统2-目录文件" class="headerlink" title="实现文件系统2: 目录文件"></a>实现文件系统2: 目录文件</h3><ul>
<li><p>首先，假设系统里的每个文件(虚拟磁盘)都有唯一的编号(id)</p>
<ul>
<li>稍后我们讨论如何维护这个编号</li>
<li>目录 = 文件名 → 文件id的映射 (这个机制天然支持链接)</li>
</ul>
</li>
<li><p>目录也是文件</p>
<ul>
<li>用文件(虚拟磁盘)来存储key-value mapping</li>
<li>支持以下操作：<ul>
<li><code>value = get(key)</code> (路径解析)</li>
<li><code>set(key, value)</code> (link)</li>
<li><code>delete(key)</code> (unlink)</li>
<li><code>get_keys()</code> (遍历目录中的文件)</li>
</ul>
</li>
</ul>
</li>
<li><p>把虚拟磁盘看成<code>_heap = { start, end }</code></p>
<ul>
<li>实现目录文件就是OSLab1 (…)</li>
<li>额外需求：<code>get_keys()</code>, <code>get()</code>应当高效</li>
</ul>
</li>
</ul>
<h3 id="实现文件系统3-元数据inode"><a href="#实现文件系统3-元数据inode" class="headerlink" title="实现文件系统3: 元数据inode"></a>实现文件系统3: 元数据inode</h3><p>我们希望文件有</p>
<ul>
<li><p>唯一的一个编号</p>
</li>
<li><p>元数据</p>
<p>信息</p>
<ul>
<li>类型：是否为目录</li>
<li>数据：大小、权限、访问时间、链接数量</li>
<li>链表实现：链表的第一个块；树实现：索引块的编号</li>
</ul>
</li>
</ul>
<ul>
<li><p>UNIX：每个文件用一个inode (index node)表示</p>
<ul>
<li><code>ls -i</code>可以查看inode编号; <code>stat</code>查看文件元数据</li>
</ul>
</li>
<li><p>元数据inode的存储</p>
<ul>
<li><p>单独区域</p>
<ul>
<li>文件id = inode编号</li>
</ul>
</li>
<li><p>目录文件中</p>
<ul>
<li>文件id = 文件的第一块编号</li>
</ul>
</li>
<li><p>文件头部</p>
<ul>
<li>文件id = 文件的第一块编号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现文件系统"><a href="#实现文件系统" class="headerlink" title="实现文件系统"></a>实现文件系统</h3><ul>
<li>实现文件系统需要考虑以下因素：<ul>
<li>虚拟磁盘的数据结构 (链表、树、……)</li>
<li>目录文件的数据结构</li>
<li>inode的表示和存储</li>
<li>balloc/bfree的实现</li>
</ul>
</li>
</ul>
<h2 id="FAT和ext2"><a href="#FAT和ext2" class="headerlink" title="FAT和ext2"></a>FAT和ext2</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>实现文件: 链表, 为每一个block都维护一个“next block”<ul>
<li>链接存储在块尾</li>
<li>统一存储链接</li>
</ul>
</li>
<li>File Allocation Table文件分配表, 集中存储next<ul>
<li>next block占多少个字节？ FAT32 → 32bit (绝大部分信息都是32bit)</li>
<li>存储在文件系统头部, super block后</li>
</ul>
</li>
</ul>
<h3 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h3><ul>
<li><p>FAT文件系统的基本思想是使用链表管理所有的数据块。FAT文件系统把若干个连续的扇区(sector)作为一个簇(cluster)，也就是我们所说的管理存储的基本单位“块”，因此如果我们希望表示一个文件，我们只需要知道：</p>
<ul>
<li>文件的第一块的编号</li>
<li>对于每一块，它下一块的编号</li>
</ul>
<p>因此，FAT文件系统专门在磁盘中开辟一个区域(File Allocation Table, FAT)，来存储每一块的下一块编号。除了编号之外，还有两种特殊的编号：</p>
<ul>
<li>free (0, 该块可以使用)</li>
<li>EOF (-1, 该块代表了某个文件的末尾)</li>
</ul>
<p>这样，FAT还可以兼用于block bitmap，用于分配/回收数据块。</p>
</li>
<li><p>Partition Boot Record(PBR), 存储在分区的头部(例如<code>/dev/sda1</code>)</p>
</li>
<li><p>block”在FAT32中称为“sector”的“cluster” (簇)<img src="../figs/fat32-pbr.jpg" alt="fat32-pbr"></p>
</li>
<li><p>文件分配表</p>
</li>
</ul>
<p><img src="../figs/FAT32.png" alt="FAT32"></p>
<ul>
<li><p>FAT32目录项</p>
<ul>
<li>不支持链接; 因此inode(元数据)直接存储在目录项中</li>
<li>目录项直接按顺序存储在文件中</li>
<li>FAT16：11字节文件名(8文件名+3扩展名)；向前兼容<img src="../figs/fat32-dirent.png" alt="fat32-dirent"></li>
</ul>
</li>
<li><p>FAT如果损坏将会导致非常严重的后果</p>
<ul>
<li>相当于链表所有的“next”都丢失了</li>
<li>解决办法：多份FAT备份 (PBR)中指定了“number of FATs”</li>
<li>通常有两个副本，同时更新</li>
</ul>
</li>
<li><p>文件系统可能碎片化</p>
</li>
<li><p>磁盘碎片整理</p>
<ul>
<li>在磁盘中进行数据的“腾挪”</li>
<li>使文件尽可能在磁盘中占有连续的块</li>
</ul>
</li>
</ul>
<h3 id="ext2文件系统"><a href="#ext2文件系统" class="headerlink" title="ext2文件系统"></a>ext2文件系统</h3><ul>
<li><p>实现文件: 索引</p>
<ul>
<li><p>文件小的时候，立即能找到它的块</p>
</li>
<li><p>文件大的时候，才用索引</p>
<p><img src="../figs/ext2-inode.gif" alt="ext2-inode"></p>
</li>
</ul>
</li>
<li><p>支持链接，因此ext2单独管理inodes</p>
<ul>
<li>每个inode占用128B或256B空间 (相比FAT来说是很大的)<ul>
<li>相比于FAT来说，浪费少量空间</li>
</ul>
</li>
<li><code>tune2fs -l /dev/sda1</code> - 查看文件系统信息</li>
</ul>
</li>
</ul>
<p><img src="../figs/ext2-groups.png" alt="ext2-groups"></p>
<ul>
<li><p>为什么要分组？</p>
<ul>
<li>把分配分为成了两级 (组级、块级)<ul>
<li>不用管理全局的bitmaps (inode/block)</li>
</ul>
</li>
<li>一定程度的性能优化<ul>
<li>尽量把相近(例如同一个目录)的文件分配在同一个组里</li>
<li>尽量把同一个文件的数据块分配在同一个组里</li>
</ul>
</li>
<li>这个设计还使磁盘大小动态调整变得容易</li>
<li>对于小文件(12个块以内，4KB块是48KB)，直接索引，没有额外的空间开销</li>
<li>对于中等文件，只使用一级索引</li>
<li>对于更大的文件(但更少)，使用更多级别的索引</li>
</ul>
</li>
<li><p>与FAT类似，ext2的目录中按顺序存储其中文件/子目录的名字和inode编号。</p>
</li>
<li><p>我理解的FAT和ext2的区别: </p>
<ul>
<li>ext2的inode集中储存, 而FAT的存在目录项中, 因此不支持链接</li>
<li>对于单个文件, FAT是用链表链接的, 每一块的下一个存在文件分配表中; 而ext2是树状结构</li>
</ul>
</li>
</ul>
<h2 id="持久数据可靠性"><a href="#持久数据可靠性" class="headerlink" title="持久数据可靠性"></a>持久数据可靠性</h2><h4 id="RAID-创建副本"><a href="#RAID-创建副本" class="headerlink" title="RAID: 创建副本"></a>RAID: 创建副本</h4><ul>
<li><p>把多个磁盘虚拟成一块磁盘</p>
</li>
<li><p>用两块磁盘(redundancy)实现容错</p>
<ul>
<li><code>read(blk)</code> -&gt; 从任何一块盘读即可</li>
<li><code>write(blk)</code> -&gt; 必须写入两块磁盘</li>
<li>实现了2X读速度</li>
<li>写速度不变</li>
<li>可以抵抗一块盘损坏 (只要磁盘没有连续损坏，就能实现容错)</li>
</ul>
</li>
<li><p>设计RAID，就是设计“如何把虚拟磁盘块映射到物理磁盘块”</p>
<ul>
<li>允许一对多映射; redundancy冗余</li>
<li>评价标准: capacity, reliablity, performance</li>
</ul>
</li>
</ul>
<h4 id="RAID-0-Striping-没有冗余"><a href="#RAID-0-Striping-没有冗余" class="headerlink" title="RAID-0(Striping) = 没有冗余"></a>RAID-0(Striping) = 没有冗余</h4><ul>
<li>无冗余, 不容错, 性能2X、容量2倍, 连续的块轮流分布在不同的Disk上(加快连续读写速度)</li>
<li>和chunk size有关, 小了读写的并行性增加, 但是跨越chunk读取可能性增加, 增加了access时间</li>
</ul>
<h4 id="RAID-1-mirror"><a href="#RAID-1-mirror" class="headerlink" title="RAID-1:(mirror)"></a>RAID-1:(mirror)</h4><ul>
<li><p>维护两块数据完全一样的磁盘实现容错</p>
</li>
<li><p>纠错码:</p>
<ul>
<li>无论有多少bit，只要至多只有1位错，我们就可以用1bit来纠错<ul>
<li>存储x, y, z, x\oplus y\oplus z<em>x</em>,<em>y</em>,<em>z</em>,<em>x</em>⊕<em>y</em>⊕<em>z</em></li>
<li>任何一个数值丢失，都能恢复出剩下的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="RAID-4-奇偶校验"><a href="#RAID-4-奇偶校验" class="headerlink" title="RAID-4(奇偶校验)"></a>RAID-4(奇偶校验)</h4><table>
<thead>
<tr>
<th align="center">Block</th>
<th align="center">磁盘1</th>
<th align="center">磁盘2</th>
<th align="center">磁盘3</th>
<th align="center">磁盘4</th>
<th align="center">磁盘P</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">0⊕1⊕2⊕3</td>
</tr>
<tr>
<td align="center">#1</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">4⊕5⊕6⊕7</td>
</tr>
<tr>
<td align="center">#2</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="center">8⊕9⊕10⊕11</td>
</tr>
<tr>
<td align="center">#3</td>
<td align="center">12</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
<td align="center">12⊕13⊕14⊕15</td>
</tr>
</tbody></table>
<p>5块盘实现：</p>
<ul>
<li><p>顺序/随机读 4X加速</p>
</li>
<li><p>顺序写入依然可以4X</p>
</li>
<li><p>随机写入：</p>
<p>P<em>′=</em>P⊕D′⊕D(1的个数奇偶)</p>
<ul>
<li>需要读出D和P；计算后再写入</li>
<li>速度减半</li>
</ul>
</li>
<li><p>恢复一块盘: 其他盘异或</p>
</li>
</ul>
<h4 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h4><p>Parity盘是整个系统的瓶颈！因此将Party盘分散开.</p>
<table>
<thead>
<tr>
<th align="center">Block</th>
<th align="center">磁盘1</th>
<th align="center">磁盘2</th>
<th align="center">磁盘3</th>
<th align="center">磁盘4</th>
<th align="center">磁盘P</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">#1</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">P</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">#2</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">P</td>
<td align="center">10</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">#3</td>
<td align="center">12</td>
<td align="center">P</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
</tr>
</tbody></table>
<ul>
<li><p>顺序/随机读 4X加速</p>
</li>
<li><p>顺序写入依然4X</p>
</li>
<li><p>随机写入：</p>
<p><em>P</em>′=<em>P</em>⊕<em>D</em>′⊕<em>D</em></p>
<ul>
<li>依然需要2读2写</li>
</ul>
</li>
</ul>
<ul>
<li><p>理论分析</p>
<p>假设有n块组成RAID</p>
<table>
<thead>
<tr>
<th align="center">RAID</th>
<th align="center">容量</th>
<th align="center">容错</th>
<th align="center">顺序读</th>
<th align="center">随机读</th>
<th align="center">顺序写</th>
<th align="center">随机写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">n</td>
<td align="center">0</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">n/2</td>
<td align="center">1..n/2</td>
<td align="center">$&gt;$ n/2</td>
<td align="center">n</td>
<td align="center">n/2</td>
<td align="center">n/2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">n-1</td>
<td align="center">1</td>
<td align="center">n-1</td>
<td align="center">n-1</td>
<td align="center">n-1</td>
<td align="center">1/2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">n-1</td>
<td align="center">1</td>
<td align="center">n-1</td>
<td align="center">n</td>
<td align="center">n-1</td>
<td align="center">n/4</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="崩溃恢复和日志"><a href="#崩溃恢复和日志" class="headerlink" title="崩溃恢复和日志"></a>崩溃恢复和日志</h2><h3 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h3><ul>
<li>考虑在FAT上创建一个目录(mkdir)的Access Path：<ol>
<li>b $\leftarrow$ balloc()，读取FAT</li>
<li>FAT[b]$ \leftarrow$ EOF</li>
<li>写入b<em>b</em>为初始数据</li>
<li>追加写入目录文件 (假设目录文件需要一个额外的数据块)<ol>
<li>b’$ \leftarrow$ balloc()</li>
<li>写入目录文件</li>
<li>FAT[b’] $\leftarrow$ EOF</li>
<li>FAT[$d_{end}$] $\leftarrow$ b’</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="系统崩溃-原子性的丧失"><a href="#系统崩溃-原子性的丧失" class="headerlink" title="系统崩溃: 原子性的丧失"></a>系统崩溃: 原子性的丧失</h3><p>考虑更简单的例子：追加写(相当于写入目录文件)</p>
<ol>
<li>$FAT[b’] \leftarrow EOF$</li>
<li>$data[b’] \leftarrow$ 数据</li>
<li>$FAT[f_{end}] \leftarrow b’$</li>
</ol>
<p>等同于链表操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span> *<span class="title">blk</span> = <span class="title">balloc</span>();</span> <span class="comment">// 找到某个blk-&gt;next == FREE</span></span><br><span class="line">blk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">file_end-&gt;next = blk;</span><br><span class="line">write_data(blk);</span><br></pre></td></tr></table></figure>

<ul>
<li>考虑所有可能崩溃的情况 (去除重复)<ul>
<li>$data[b’] $→ ❌ (random writes)</li>
<li>$FAT[f_{end}]$ → ❌ (corrupted FAT)</li>
<li>$FAT[b’]$→ ❌ (dead block/leak)</li>
<li>$data[b’]$ → $FAT[f_{end}]$ → ❌ (random writes + corrupted FAT)</li>
<li>$FAT[b’]$→ $data[b’]$ → ❌ (dead block x 2)</li>
<li>$FAT[b’] $→ $FAT[f_{end}]$ → ❌ (corrupted file)</li>
<li>$FAT[f_{end}]$→ $FAT[b’]$ → $data[b’] $✅</li>
</ul>
</li>
</ul>
<p>对于ext2, 文件追加写(一块)，需要写入：</p>
<ol>
<li>inode (size、索引); 2. 数据bitmap; 3. 数据</li>
</ol>
<p>可能的崩溃情况：</p>
<ul>
<li>{1} - corrupted filesystem</li>
<li>{2} - dead block</li>
<li>{3} - random writes</li>
<li>{1,2}- incorrect data</li>
<li>{1,3} - corrupted filesystem</li>
<li>{2,3} - dead block</li>
</ul>
<h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><ul>
<li><p>功能: 发现不一致并修复</p>
</li>
<li><p>步骤:</p>
<ul>
<li>Superblock: <ul>
<li>检查superblock是否合理; 找到可能崩溃的superblock, 决定是否使用其备份</li>
</ul>
</li>
<li>Free blocks:<ul>
<li>扫描inodes, (double)indirect blocks等, 找到已经分配过的块.</li>
<li>如果allocation bitmaps和inodes不一致, 相信inodes</li>
<li>对于inodes进行同样的检查</li>
<li>inode state, inode links(计数), 备份, Bad blocks(指向非法区域的), 目录文件(尤其是.和..)</li>
</ul>
</li>
</ul>
<p>简略的为:</p>
<p>在文件操作时不管崩溃一致性，但在崩溃后扫描磁盘进行补救</p>
<ul>
<li>扫描inodes里的所有数据块，检查bitmap的一致性</li>
<li>检查inode数据是否“看起来合法”，否则删除</li>
<li>检查链接情况 (没有链接的inode被移到lost+found目录中)</li>
</ul>
</li>
</ul>
<h3 id="日志-write-ahead-logging-journaling"><a href="#日志-write-ahead-logging-journaling" class="headerlink" title="日志(write-ahead logging, journaling)"></a>日志(write-ahead logging, journaling)</h3><ul>
<li><p>更新磁盘前先记录所做操作</p>
</li>
<li><p>把操作以append only的方式记录下来</p>
<ul>
<li>先写入数据 (TXBegin和数据)；然后sync</li>
<li>写入TXEnd；再次sync</li>
</ul>
</li>
<li><p>用一个额外的指针维护journal完成的时刻</p>
<ul>
<li>journal write (写入TXBegin和数据)</li>
<li>journal commit (TXEnd + sync)</li>
<li>之后可以自由更新数据结构和指针 (完成后到达checkpoint)</li>
<li>procfs中有jbd的统计信息</li>
</ul>
</li>
<li><p>防止日志过长:</p>
<ul>
<li>circular log: 到达checkpoint后free</li>
</ul>
</li>
<li><p>恢复崩溃:</p>
<ul>
<li><p>从指针开始，向后重做journal中记录的操作</p>
<ul>
<li>(redo logging)</li>
<li>还有一种undo logging，记录操作的inverse (数据库中常用)</li>
</ul>
</li>
<li><p>Journaling实现了文件系统操作的原子性</p>
<ul>
<li>若干个block writes，要么全部发生，要么一个都不发生</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h2><h3 id="Hello-OS-world"><a href="#Hello-OS-world" class="headerlink" title="Hello, OS world"></a>Hello, OS world</h3><h4 id="编译-链接"><a href="#编译-链接" class="headerlink" title="编译, 链接"></a>编译, 链接</h4><ul>
<li>strace -f查看进程和他的子进程的所有系统调用</li>
<li>gcc -o hello hello.c<ul>
<li>子进程1: 编译器compiler写入a.s汇编代码</li>
<li>子进程2: 汇编器assembler写入a.o(ELF…)</li>
<li>子进程3: 链接器linker写入a.out(ELF…)</li>
</ul>
</li>
<li>readelf: hello中有什么</li>
</ul>
<h4 id="终端与shell"><a href="#终端与shell" class="headerlink" title="终端与shell"></a>终端与shell</h4><ul>
<li>==I/O设备模型==: 设备是三种操作的集合: <ul>
<li>发送命令、读取状态、传输数据</li>
</ul>
</li>
<li>==设备驱动==: os中负责与设备交互的程序. 根据设备类型不同, 给每一类设备以统一的接口访问, 实现这个接口的就是设备驱动程序.</li>
<li>shell用read从0号文件描述符读入, 按下回车read返回</li>
</ul>
<ul>
<li><p>./hello如何被执行</p>
<ul>
<li>fork-execve</li>
<li>execve保留绝大部分进程状态,如文件描述符, 管道和重定向是改变文件描述符</li>
<li>sudo echo hello &gt; /etc/a没用的原因: 在execve之前open就已经失败了,还没有sudo</li>
</ul>
</li>
</ul>
<ul>
<li><p>==hello的第一条指令在哪里?==</p>
<ul>
<li>ld.so的_start()</li>
</ul>
</li>
<li><p>==hello的main函数执行之前, 系统中发生了什么?==</p>
<ul>
<li>加载器的$_$start, $_$init, 之后调用hello的 $_$start, $__$libc$_$start$_$main…</li>
</ul>
<p><img src="../figs/callgraph.png" alt="callgraph"></p>
<ul>
<li>gdb: starti <ul>
<li>发现在加载器的$_$start()(这是动态链接, 对于静态链接就是在程序里)</li>
</ul>
</li>
<li>info inferiors + pmap<ul>
<li>有hello, ld-xxx.so</li>
<li>没有看到libc代码</li>
</ul>
</li>
<li>b $_$start() + 再次pmap<ul>
<li>有了libc(加载器做的mmap)</li>
</ul>
</li>
<li>最后到main()</li>
<li>constructor函数: 可以在main之前执行</li>
<li>printf可能会被优化为puts</li>
</ul>
</li>
<li><p>printf()代码位置</p>
<ul>
<li>动态链接细节不考, 如got plt</li>
</ul>
</li>
<li><p>printf()是线程安全的吗?==如何实现线程安全的printf?==</p>
<ul>
<li>并发编程题目: <strong>条件变量</strong>, 信号量</li>
<li>复习生产者消费者问题</li>
</ul>
</li>
<li><p>printf字符串末尾没有换行:</p>
<ul>
<li>printf有libc的缓冲区<ul>
<li>setbuf(); fork的神坑(连缓冲区一起复制fork+printf两次, 6 or 8)</li>
<li>到文件:总是缓冲; 到中断: 换行</li>
</ul>
</li>
<li>ltrace有printf</li>
</ul>
</li>
<li><p>printf背后的系统调用: write</p>
</li>
<li><p>write写到哪: 文件描述符对应的文件, 例如一个设备/dev/ttyx, 或者是文件系统中的一个文件</p>
</li>
<li><p>==文件系统如何实现== ==FAT==, ==ext2==(inode)</p>
</li>
<li><p>==如何保护数据不受损坏==:</p>
<ul>
<li>把不可靠的磁盘变可靠: RAID; 奇偶校验允许一块盘坏; 校验位均匀分布在各个盘上</li>
<li>实现崩溃一致性: fsck, 日志</li>
</ul>
</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/01/启发性算法/" rel="next" title="启发性算法">
                <i class="fa fa-chevron-left"></i> 启发性算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程threads"><span class="nav-number">1.</span> <span class="nav-text">线程threads</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序、原子性、可见性的丧失"><span class="nav-number">1.1.</span> <span class="nav-text">顺序、原子性、可见性的丧失</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁和条件变量的使用"><span class="nav-number">2.</span> <span class="nav-text">锁和条件变量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁"><span class="nav-number">2.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量"><span class="nav-number">2.2.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁的实现"><span class="nav-number">3.</span> <span class="nav-text">锁的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件层"><span class="nav-number">3.1.</span> <span class="nav-text">硬件层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LOCK指令"><span class="nav-number">3.1.1.</span> <span class="nav-text">LOCK指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LL-SC"><span class="nav-number">3.1.2.</span> <span class="nav-text">LL/SC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">3.2.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#能睡眠的互斥锁"><span class="nav-number">3.3.</span> <span class="nav-text">能睡眠的互斥锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发数据结构"><span class="nav-number">4.</span> <span class="nav-text">并发数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件变量-1"><span class="nav-number">5.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者问题"><span class="nav-number">5.1.</span> <span class="nav-text">生产者消费者问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量Semaphores"><span class="nav-number">6.</span> <span class="nav-text">信号量Semaphores</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哲学家吃饭问题"><span class="nav-number">6.1.</span> <span class="nav-text">哲学家吃饭问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发bugs"><span class="nav-number">7.</span> <span class="nav-text">并发bugs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁-ABBA"><span class="nav-number">7.1.</span> <span class="nav-text">死锁 (ABBA)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性违反-ABA"><span class="nav-number">7.2.</span> <span class="nav-text">原子性违反 (ABA)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序违反-BA"><span class="nav-number">7.3.</span> <span class="nav-text">顺序违反 (BA)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争"><span class="nav-number">7.4.</span> <span class="nav-text">数据竞争</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程抽象"><span class="nav-number">8.</span> <span class="nav-text">进程抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分时复用处理器"><span class="nav-number">8.1.</span> <span class="nav-text">分时复用处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统：实现虚拟化"><span class="nav-number">8.2.</span> <span class="nav-text">操作系统：实现虚拟化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理应用程序有序执行"><span class="nav-number">8.3.</span> <span class="nav-text">管理应用程序有序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程管理API"><span class="nav-number">8.4.</span> <span class="nav-text">进程管理API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程状态"><span class="nav-number">8.5.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接执行限制"><span class="nav-number">8.6.</span> <span class="nav-text">直接执行限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终端和Shell"><span class="nav-number">9.</span> <span class="nav-text">终端和Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件描述符"><span class="nav-number">9.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道：进程间通信"><span class="nav-number">9.2.</span> <span class="nav-text">管道：进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号机制"><span class="nav-number">9.3.</span> <span class="nav-text">信号机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出到终端和重定向到文件的区别"><span class="nav-number">9.4.</span> <span class="nav-text">输出到终端和重定向到文件的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度"><span class="nav-number">10.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proportional-Share"><span class="nav-number">11.</span> <span class="nav-text">Proportional Share</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Linux-Completely-Fair-Scheduler-CFS"><span class="nav-number">11.1.</span> <span class="nav-text">The Linux Completely Fair Scheduler (CFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理器"><span class="nav-number">11.2.</span> <span class="nav-text">多处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚存抽象"><span class="nav-number">12.</span> <span class="nav-text">虚存抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地址翻译"><span class="nav-number">12.1.</span> <span class="nav-text">地址翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段"><span class="nav-number">12.2.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空闲内存管理"><span class="nav-number">12.3.</span> <span class="nav-text">空闲内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页"><span class="nav-number">12.4.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap"><span class="nav-number">12.5.</span> <span class="nav-text">mmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-写时复制"><span class="nav-number">12.6.</span> <span class="nav-text">fork: 写时复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">12.7.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态链接程序的地址空间"><span class="nav-number">12.8.</span> <span class="nav-text">静态链接程序的地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态链接程序的地址空间"><span class="nav-number">12.9.</span> <span class="nav-text">动态链接程序的地址空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#期中复习"><span class="nav-number">13.</span> <span class="nav-text">期中复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-World的故事"><span class="nav-number">13.1.</span> <span class="nav-text">Hello World的故事:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-操作系统视角"><span class="nav-number">13.2.</span> <span class="nav-text">进程: 操作系统视角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新理解系统调用"><span class="nav-number">13.3.</span> <span class="nav-text">重新理解系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统与并发"><span class="nav-number">13.4.</span> <span class="nav-text">操作系统与并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储介质"><span class="nav-number">14.</span> <span class="nav-text">存储介质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O设备与驱动"><span class="nav-number">15.</span> <span class="nav-text">I/O设备与驱动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-number">16.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统概念"><span class="nav-number">16.1.</span> <span class="nav-text">文件系统概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统API"><span class="nav-number">17.</span> <span class="nav-text">文件系统API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#挂载"><span class="nav-number">17.1.</span> <span class="nav-text">挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录管理"><span class="nav-number">17.2.</span> <span class="nav-text">目录管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件管理：打开文件"><span class="nav-number">17.3.</span> <span class="nav-text">文件管理：打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开目录"><span class="nav-number">17.4.</span> <span class="nav-text">打开目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件描述符-1"><span class="nav-number">17.5.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存文件"><span class="nav-number">17.6.</span> <span class="nav-text">保存文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统实现"><span class="nav-number">18.</span> <span class="nav-text">文件系统实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#块设备"><span class="nav-number">18.1.</span> <span class="nav-text">块设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现文件系统1-虚拟磁盘"><span class="nav-number">18.2.</span> <span class="nav-text">实现文件系统1: 虚拟磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现文件系统2-目录文件"><span class="nav-number">18.3.</span> <span class="nav-text">实现文件系统2: 目录文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现文件系统3-元数据inode"><span class="nav-number">18.4.</span> <span class="nav-text">实现文件系统3: 元数据inode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现文件系统"><span class="nav-number">18.5.</span> <span class="nav-text">实现文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FAT和ext2"><span class="nav-number">19.</span> <span class="nav-text">FAT和ext2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题分析"><span class="nav-number">19.1.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT32"><span class="nav-number">19.2.</span> <span class="nav-text">FAT32</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ext2文件系统"><span class="nav-number">19.3.</span> <span class="nav-text">ext2文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久数据可靠性"><span class="nav-number">20.</span> <span class="nav-text">持久数据可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RAID-创建副本"><span class="nav-number">20.0.1.</span> <span class="nav-text">RAID: 创建副本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAID-0-Striping-没有冗余"><span class="nav-number">20.0.2.</span> <span class="nav-text">RAID-0(Striping) = 没有冗余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAID-1-mirror"><span class="nav-number">20.0.3.</span> <span class="nav-text">RAID-1:(mirror)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAID-4-奇偶校验"><span class="nav-number">20.0.4.</span> <span class="nav-text">RAID-4(奇偶校验)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAID-5"><span class="nav-number">20.0.5.</span> <span class="nav-text">RAID-5</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#崩溃恢复和日志"><span class="nav-number">21.</span> <span class="nav-text">崩溃恢复和日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘上的数据结构"><span class="nav-number">21.1.</span> <span class="nav-text">磁盘上的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统崩溃-原子性的丧失"><span class="nav-number">21.2.</span> <span class="nav-text">系统崩溃: 原子性的丧失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsck"><span class="nav-number">21.3.</span> <span class="nav-text">fsck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志-write-ahead-logging-journaling"><span class="nav-number">21.4.</span> <span class="nav-text">日志(write-ahead logging, journaling)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#期末复习"><span class="nav-number">22.</span> <span class="nav-text">期末复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-OS-world"><span class="nav-number">22.1.</span> <span class="nav-text">Hello, OS world</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译-链接"><span class="nav-number">22.1.1.</span> <span class="nav-text">编译, 链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终端与shell"><span class="nav-number">22.1.2.</span> <span class="nav-text">终端与shell</span></a></li></ol></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
