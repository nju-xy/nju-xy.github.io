<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="XY&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="XY&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XY&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>XY's blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XY's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/Fingerprinting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/12/Fingerprinting/" itemprop="url">高级算法之指纹</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-12T10:25:50+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Polynomial-Identity-Testing-PIT"><a href="#1-Polynomial-Identity-Testing-PIT" class="headerlink" title="1. Polynomial Identity Testing (PIT)"></a>1. Polynomial Identity Testing (PIT)</h2><ul>
<li><strong>Polynomial Identity Testing (PIT)</strong>: 给定两个多项式, 确定他们是否相同</li>
</ul>
<h3 id="单变量情形"><a href="#单变量情形" class="headerlink" title="单变量情形"></a>单变量情形</h3><ul>
<li><p>问题</p>
<ul>
<li>输入: 两个多项式$f$, $g\in \mathbb F [x]$(单变量域(filed)), 度都为$d$(最高次项次数)</li>
<li>确定是否有$f\equiv g$</li>
</ul>
</li>
<li><p>多项式$f\in \mathbb F[x]$为$f(x)=\sum_{i=0}^\infty a_ix^i$, $a_i\in \mathbb F$</p>
</li>
<li><p>$f$的degree是最大的满足$a_i\neq 0$的$i$; 如果所有$a_i=0$, 则$f\equiv 0$, 称为zero-polynomial</p>
</li>
<li><p>假设$f$为黑盒, 因此不能直接判断$a_i$是否为0</p>
</li>
<li><p>确定性解法</p>
<ul>
<li><p>从$\mathbb F$中取$x_1, x_2, \cdots, x_{d+1}$, 判断$f(x_1), f(x_2), \cdots, f(x_{d+1})$是否都为0</p>
</li>
<li><p>根据: </p>
<table>
<thead>
<tr>
<th>算数基本定理</th>
</tr>
</thead>
<tbody><tr>
<td>任意度为$d$的单变量多项式至多有$d$个根</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="最简单的随机算法"><a href="#最简单的随机算法" class="headerlink" title="最简单的随机算法"></a>最简单的随机算法</h4><ul>
<li><p>算法:</p>
<ul>
<li>假设有有限集$S\subseteq \mathbb F$</li>
<li>随机选取$r\in S$</li>
<li>如果$f(r)=0$返回’yes’, 否则返回’no’ </li>
</ul>
</li>
<li><p>若$f=0$, 必定返回’yes’, 正确</p>
</li>
<li><p>若$f\neq 0$, 也有可能返回’yes’. 但是因为$f$至多有$d$个根, 所以算法结果错误的概率上界为<br>$$<br>Pr[f(r)=0]\le \frac{d}{|S|}<br>$$</p>
</li>
<li><p>如果取$|S|=2d$, 则错误率至多1/2. 想要错误率小于任意常数$\delta$, 只需要重复$\log_2 \delta$次</p>
</li>
</ul>
<h3 id="1-1-相等问题的通信复杂度"><a href="#1-1-相等问题的通信复杂度" class="headerlink" title="1.1 相等问题的通信复杂度"></a>1.1 相等问题的通信复杂度</h3><ul>
<li><p>Alice有私密输入a, Bob有私密输入b, 他们希望通过通信协议来计算函数$f(a,b)$. 通信复杂度是最坏情况下Alice和Bob之间需要传输的bit数</p>
</li>
<li><p>判断相等性的函数为$EQ: { 0,1 }^n \times { 0,1 }^n \to { 0,1 }$</p>
<p>对于任意$a, b\in{0,1}^n$,<br>$$<br>EQ(a,b)=<br>\begin{cases}<br>0 &amp; a = b \\<br>1 &amp; a\ne b<br>\end{cases}<br>$$</p>
</li>
<li><p>trival way: Bob把整个b传给Alice, Alice判断是否$a=b$. 需要$n$传输位</p>
<table>
<thead>
<tr>
<th><strong>Theorem (yao 1979)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>所有的计算两个n位串是否相等的确定通信协议, 最坏情况下, 需要n传输位</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h4><ul>
<li><p>准备工作</p>
<ul>
<li><p>用两个度至多为$n-1$的单变量多项式来表示$a, b$,<br>$$<br>f(x)=\sum_{i=0}^{n-1}a_ix^i, g(x)=\sum_{i=0}^{n-1}b_ix^i<br>$$</p>
</li>
<li><p>$f$和$g$定义在有限域$\mathbb Z_p={0,1,\cdots, p-1}$上, $p$为合适的素数</p>
</li>
</ul>
</li>
<li><p><strong>A randomized protocol for EQ</strong></p>
<ul>
<li>Bob: <ul>
<li>随机选择$r\in \mathbb Z_p$</li>
<li>发送$r$和$g(r)$给Alice</li>
</ul>
</li>
<li>Alice收到后<ul>
<li>计算$f(r)$</li>
<li>如果$f(r)=g(r)$返回’yes’; 否则返回’no’</li>
</ul>
</li>
</ul>
</li>
<li><p>通讯复杂度$O(\log p)$</p>
</li>
<li><p>错误情况: $f\not\equiv g$但是$f(r)=g(r)$. 因为$f, g$的度至多为$n-1$, $r$是从$p$个数中随机选取, 所以<br>$$<br>Pr[f(r)=g(r)]\le \frac{n-1}{p}<br>$$</p>
</li>
<li><p>通过选取$p\in[n^2, 2n^2]$(根据切比雪夫, 这样的素数一定存在), 上述错误率至多$O(1/n)$, 通讯复杂度$O(\log n)$, 比确定性算法提升较大</p>
</li>
</ul>
<h3 id="1-2-Schwartz-Zippel-Theorem"><a href="#1-2-Schwartz-Zippel-Theorem" class="headerlink" title="1.2 Schwartz-Zippel Theorem"></a>1.2 Schwartz-Zippel Theorem</h3><ul>
<li><strong>Schwartz-Zippel Theorem</strong>: 令$f\in \mathbb [x_1,x_2, \cdots, x_n]$为$\mathbb F$中度为$d$的多元多项式. 如果$f\not\equiv 0$, 那么对于任意有限集合$S\subset F$, 随机选取$r_1, r_2, \cdots, r_n\in S$, $Pr[f(r_1, r_2, \cdots, r_n)=0]\le \frac{d}{|S|}$.</li>
<li><strong>Schwartz-Zippel Theorem</strong>定理说明对于任何非0的$n$变量度为$d$的多项式, 在任意立方体$S^n$中的根的数量至多为$d\cdot |S|^{n-1}$</li>
<li>注意多元多项式中的度为所有变量的指数之和</li>
</ul>
<h4 id="证明-数归"><a href="#证明-数归" class="headerlink" title="证明(数归)"></a>证明(数归)</h4><ul>
<li><p>Induction basis: </p>
<ul>
<li>$n=1$为单变量情况, 上面已经讨论过</li>
</ul>
</li>
<li><p>Induction hypothesis:</p>
<ul>
<li>假设定理对于所有$m$元多项式($m&lt;n$)成立</li>
</ul>
</li>
<li><p>Induction step:</p>
<ul>
<li><p>对于任意至多$d$阶的$n$元多项式$f(x_1,x_2, \cdots, x_n)$, 将$f$写成<br>$$<br>f(x_1,x_2,\cdots, x_n)=\sum_{i=0}^kx_n^if_i(x_1,x_2,\cdots, x_{n-1})<br>$$<br>其中$k$为$x_n$的最高度, 也就是$f_k$的度至多为$d-k$, 且$f_k\not\equiv 0$</p>
</li>
<li><p>具体的, 把$f$分成两部分:<br>$$<br>f(x_1,x_2,\cdots,x_n)=x_n^kf_k(x_1,x_2,\cdots,x_{n-1})+\bar f(x_1,x_2,\cdots,x_n)<br>$$<br>其中:</p>
<ul>
<li>$f_k\not\equiv0$定义如上, 度至多$d-k$</li>
<li>$\bar f(x_1,x_2,\cdots, x_n)=\sum_{i=0}^{k-1}x_n^i f_i(x_1,x_2,\cdots, x_{n-1})$, 因此$\bar f$中没有带$x_n^k$的项</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>$Pr[f(r_1,r_2,\cdots,r_n)=0]= Pr[f(\vec r)=0|f_k(r_1,r_2,\cdots, r_{n-1})=0]\cdot Pr[f_k(r_1,r_2,\cdots, r_{n-1})=0]$</p>
<p>$+ Pr[f(\vec r)= 0|f_k(r_1,r_2,\cdots, r_{n-1})\ne 0]  \cdot Pr[f_k(r_1,r_2,\cdots, r_{n-1})\ne 0]$</p>
</li>
</ul>
<ul>
<li>其中$f_k(r_1,r_2,\cdots, r_{n-1})$是$n-1$变量$d-k$阶多项式, 且$f_k\not\equiv 0$. 根据猜想, 我们有</li>
</ul>
<p>$$<br>Pr[f_k(r_1,r_2\cdots,r_{n-1})=0]\le \frac{d-k}{|S|}<br>$$</p>
<ul>
<li><p>考虑条件$f_k(r_1,r_2, \cdots, r_{n-1})\ne 0$.该条件保证了<br>$$<br>f(r_1,\cdots, r_{n-1},x_n)=x_n^kf_k(r_1,r_2,\cdots,r_{n-1})+\bar f(r_1,r_2,\cdots,r_{n-1},x_n)=g_{r_1\cdots r_{n-1}}(x_n)<br>$$<br>是一个非0的单变量$x_n$的多项式, 且度为k, 且$g_{r_1\cdots r_{n-1}}\not\equiv 0$. 因此$g_{r_1\cdots r_{n-1}}(r_n) =0$的概率至多$\frac{k}{|S|}$</p>
</li>
<li><p>因此<br>$$<br>Pr[f(\vec r)=0|f_k(r_1,r_2,\cdots, r_{n-1})\ne 0] \=Pr[g_{r_1\cdots r_{n-1}}(r_n) =0|f_k(r_1,r_2,\cdots, r_{n-1})\ne 0] \le \frac{k}{|S|}<br>$$</p>
</li>
<li><p>因此<br>$$<br>Pr[f(r_1,r_2,\cdots,r_n)=0]\le \frac{d-k}{|S|}+\frac{k}{|S|}=\frac{d}{|S|}<br>$$<br>得证.</p>
</li>
</ul>
<h2 id="2-Fingerprinting"><a href="#2-Fingerprinting" class="headerlink" title="2. Fingerprinting"></a>2. Fingerprinting</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/11/Cut/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/11/Cut/" itemprop="url">高级算法之最小割和最大割</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T22:24:16+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最小割和最大割"><a href="#最小割和最大割" class="headerlink" title="最小割和最大割"></a>最小割和最大割</h1><h2 id="1-最小割"><a href="#1-最小割" class="headerlink" title="1 最小割"></a>1 最小割</h2><h3 id="1-1-Karger’s-Contraction-algorithm"><a href="#1-1-Karger’s-Contraction-algorithm" class="headerlink" title="1.1 Karger’s Contraction algorithm"></a>1.1 Karger’s <em>Contraction</em> algorithm</h3><ul>
<li>Contraction操作: $Contract(G, uv)$表示将图G中点u和v合并, uv之间的边删除</li>
</ul>
<h4 id="RandomContract算法"><a href="#RandomContract算法" class="headerlink" title="RandomContract算法"></a>RandomContract算法</h4><ul>
<li><p>while |V| &gt; 2 do</p>
<ul>
<li>随机选择边$uv\in E$</li>
<li>$G=Contract(G, uv)$</li>
</ul>
</li>
<li><p>return $C=E$</p>
</li>
<li><p>复杂度: 运行$n-2$次Contract, 每次Contract为$O(n)$, RandomContract为$O(n^2)$</p>
</li>
</ul>
<h3 id="1-2-Analysis-of-accuracy"><a href="#1-2-Analysis-of-accuracy" class="headerlink" title="1.2 Analysis of accuracy"></a>1.2 Analysis of accuracy</h3><table>
<thead>
<tr>
<th>引理</th>
</tr>
</thead>
<tbody><tr>
<td>对于某一特定最小割C, $$p_c=Pr[C ~ is ~ returned ~ by ~ RandomContract]\ge \frac{2}{n(n-1)}$$</td>
</tr>
</tbody></table>
<p>证明要点:</p>
<ul>
<li><p>C为G的最小割, $e\not\in C$, 则C是$G’=Contract(G,e)$的最小割</p>
<ul>
<li>因为G’中的割都是G中的割, 且C在G’中”存活”, 所以C是G’的最小割</li>
</ul>
</li>
<li><p>C被RandomContract返回当且仅当对于任意$i=1,2,…,n-2, e_i\not\in C$</p>
</li>
<li><p>根据链法则, $p_C$转化为$\Pi_{i=1}^n Pr[e_i\not\in C|\forall  j &lt; i, e_j\not\in C]$</p>
</li>
<li><p>证明$|E|\ge \frac{|V||C|}{2}$</p>
<ul>
<li>每个点的度至少为$|C|$</li>
<li>所有点度之和为$2|E|$</li>
</ul>
</li>
<li><p>$p_i=1-\frac{|C|}{|E_i|}\ge 1-\frac{2}{V_i}=1-\frac{2}{n-i+1}$</p>
</li>
<li><p>运行RandomContract算法$t=\frac{n(n-1)\ln n}{2}$次, 就可以达到$1-\frac{1}{n}$的准确率, 称为with high probability</p>
</li>
<li><p>总复杂度$O(n^4\log n)$</p>
</li>
</ul>
<h3 id="1-3-A-Corollary-by-the-Probabilistic-Method"><a href="#1-3-A-Corollary-by-the-Probabilistic-Method" class="headerlink" title="1.3 A Corollary by the Probabilistic Method"></a>1.3 A Corollary by the Probabilistic Method</h3><table>
<thead>
<tr>
<th>推论</th>
</tr>
</thead>
<tbody><tr>
<td>对于n度图G, 不同的割的数量最多为$n(n−1)/2$</td>
</tr>
</tbody></table>
<ul>
<li>证明: $1\ge p_{correct}=\sum_{C\in \mathcal C}p_c\ge |\mathcal C|\frac{2}{n(n-1)}$</li>
</ul>
<h3 id="1-4-Fast-Min-Cut"><a href="#1-4-Fast-Min-Cut" class="headerlink" title="1.4 Fast Min-Cut"></a>1.4 Fast Min-Cut</h3><ul>
<li><p>观察发现, 当图太Contract时, 成功率才低</p>
</li>
<li><p>改进思路: 先将顶点数Contract到一个相对小的值, 利用递归找到更小的那个割</p>
</li>
<li><p>改进方法:</p>
<ul>
<li>将RandomContract中的终止条件$|V|\ge 2$改为$|V|\ge t$, 后面发现$t=\lceil1+n/\sqrt 2 \rceil$较合适</li>
<li>FastCut(G):<ul>
<li>if $|V|\le 6$穷举得到最小割</li>
<li>else <ul>
<li>G1 = RandomContract(G, t)</li>
<li>G2 = RandomContract(G, t)</li>
<li>返回FastCut(G1)和FastCut(G2)中较小的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>易证RandomContract后最小割大小不变的概率大于等于1/2</p>
</li>
<li><p>FastCut返回的不是最小割的概率为$\Omega(1/\log n)$</p>
</li>
<li><p>一次FastCut时间复杂度$O(n^2\log n)$</p>
</li>
<li><p>运行FastCut算法$O((\log n)^2)$次, 准确率达到$1-O(1/n)$, 总复杂度$O(n^2\log^3 n)$</p>
</li>
</ul>
<h2 id="2-最大割"><a href="#2-最大割" class="headerlink" title="2 最大割"></a>2 最大割</h2><ul>
<li>NPC</li>
</ul>
<h3 id="2-1-Greedy-algorithm"><a href="#2-1-Greedy-algorithm" class="headerlink" title="2.1 Greedy algorithm"></a>2.1 Greedy algorithm</h3><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法:"></a>贪心算法:</h4><ul>
<li><p>初始$S=T=\emptyset$</p>
</li>
<li><p>for i = 1, 2, …, n</p>
<ul>
<li>$v_i$加入S或者T, 以最大化当前的$|E(S, T)|$</li>
</ul>
</li>
<li><p>多项式时间</p>
</li>
</ul>
<h4 id="近似度分析"><a href="#近似度分析" class="headerlink" title="近似度分析"></a>近似度分析</h4><ul>
<li>$OPT_G$上界为|E|</li>
<li>引理1: $|E|=\sum_{i=1}^n(|E(S_i, \{v_i\})| + |E(T_i, \{v_i\}|)$<ul>
<li>可以理解为每条边遍历一次</li>
</ul>
</li>
<li>引理2: $SOL_G=\sum_{i=1}^n max(|E(S_i, \{v_i\})| , |E(T_i, \{v_i\}|)$<ul>
<li>理解为每次选择和S或T相连的边较多的</li>
</ul>
</li>
<li>因此$SOL_G\ge \frac{1}{2}OPT_G$</li>
<li>近似比为0.5</li>
</ul>
<h3 id="2-2-Derandomazation-by-conditional-expectation"><a href="#2-2-Derandomazation-by-conditional-expectation" class="headerlink" title="2.2 Derandomazation by conditional expectation"></a>2.2 Derandomazation by conditional expectation</h3><ul>
<li><p>用$X_v$为0或1表示$v$属于S还是T</p>
</li>
<li><p>$\mathbb E[|E(S,T)|]=\sum_{uv\in E}\mathbb E[I[X_u\neq X_v]] = \frac{|E|}{2}\ge \frac{OPT_G}{2}$</p>
</li>
<li><p>因此至少有一组分割满足$E(S,T)\ge\frac{OPT_G}{2}$</p>
</li>
<li><p>可以作一棵决策树, 第i层表示$v_i$的选择</p>
</li>
<li><p>对于$x_{v_1}$, 因为$\mathbb E[E(S, T)]=\frac{1}{2}\mathbb E[E(S, T)|x_{v_1}=0]+\frac{1}{2}\mathbb E[E(S, T)|x_{v_1}=1]$, 所以存在$x_1\in{0,1}$, 满足$\mathbb E[E(S, T)|x_{v_1}=x_1]\ge \mathbb E[E(S,T)]$</p>
</li>
<li><p>同理存在一系列$x_i$满足$\mathbb E[E(S, T)|x_{v_1}=x_1, x_{v_2}=x_2, …, x_{v_i}=x_i]\ge $</p>
<p>$\mathbb E[E(S,T)|x_{v_1}=x_1, x_{v_2}=x_2, …, x_{v_{i-1}}=x_{i-1}]$</p>
</li>
<li><p>综上存在$x_1, x_2, …, x_n$的01序列使得$\mathbb E[E(S, T)|]\le \mathbb E[E(S, T)|x_{v_1}=x_1, x_{v_2}=x_2, …, x_{v_n}=x_n]$</p>
</li>
<li><p>也就是存在$\hat S, \hat T$满足$\mathbb E[\hat S, \hat T]\ge \frac{OPT_G}{2}$</p>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>初始$S=T=\emptyset$</li>
<li>for i = 1, 2, …, n<ul>
<li>$v_i$选择加入S或T, 满足在前面选择的基础上最大化割的均值, 也就是使得$\mathbb     E[E(S,T)|x_{v_1}=x_1, x_{v_2}=x_2, …, x_{v_{i}}=x_{i}]$最大 (计算该期望只需要计算还没完全确定的边)</li>
</ul>
</li>
<li>实际上算法和上面的贪心完全一致</li>
</ul>
<h3 id="2-3-Derandomazation-by-pairwise-independence"><a href="#2-3-Derandomazation-by-pairwise-independence" class="headerlink" title="2.3 Derandomazation by pairwise independence"></a>2.3 Derandomazation by pairwise independence</h3><ul>
<li><p>注意上面算法实际上只要求成对独立, 因此可以优化</p>
</li>
<li><p>用$Y_v$表示v属于S还是T</p>
</li>
<li><p>定理:</p>
<ul>
<li>01随机变量$X_1, X_2, …, X_k$</li>
<li>$S_1, S_2, …, S_{2^k-1}\subseteq {1,2,…,k}$为${1,2,…,k}$的非空子集的枚举</li>
<li>对任意i, $Y_i=\oplus_{j\in S_i} X_j$</li>
<li>$Y_1, Y_2,…,Y_{2^k-1}$就是成对独立均匀随机位</li>
</ul>
</li>
<li><p>如果$Y_v$是按照上面方式构造, $k=\lceil\log(n+1)\rceil$</p>
<p>有$\mathbb E[|E(S,T)|]=\sum_{uv\in E} Pr[Y_u\neq Y_v=|E|/2$</p>
</li>
<li><p>因此存在S, T满足$|E(S,T)|\ge |E|/2\ge OPT/2$</p>
</li>
<li><p>搜索空间降低为$2^k-1=O(n^2)$</p>
</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>$k=\lceil\log(n+1)\rceil$</li>
<li>对所有$\vec x\in \{0,1\}^k$<ul>
<li>初始$S_{\vec x}=T_{\vec x}=\emptyset$</li>
<li>for i = 1, 2, …, n<ul>
<li>if $\oplus_{j: \lfloor i/2^j\rfloor \mod 2 = 1} x_j=1$(即i二进制下为1的位都异或起来),  $v_i$加入$S_{\vec x}$</li>
<li>else  $v_i$加入$T_{\vec x}$</li>
</ul>
</li>
</ul>
</li>
<li>返回$\{S_{\vec x}, T_{\vec x}\}$有最大$|E(S_{\vec x}, T_{\vec x})|$</li>
</ul>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul>
<li>该算法的实质是遍历解空间, 但是解空间比之前小得多</li>
<li>近似比也是1/2</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/os期末复习 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/os期末复习 /" itemprop="url">OS期末复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T14:41:24+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Hello-OS-world"><a href="#Hello-OS-world" class="headerlink" title="Hello, OS world"></a>Hello, OS world</h3><h4 id="编译-链接"><a href="#编译-链接" class="headerlink" title="编译, 链接"></a>编译, 链接</h4><ul>
<li>strace -f查看进程和他的子进程的所有系统调用</li>
<li>gcc -o hello hello.c<ul>
<li>子进程1: 编译器compiler写入a.s汇编代码</li>
<li>子进程2: 汇编器assembler写入a.o(ELF…)</li>
<li>子进程3: 链接器linker写入a.out(ELF…)</li>
</ul>
</li>
<li>readelf: hello中有什么</li>
</ul>
<h4 id="终端与shell"><a href="#终端与shell" class="headerlink" title="终端与shell"></a>终端与shell</h4><ul>
<li>==I/O设备模型==: 设备是三种操作的集合: <ul>
<li>发送命令、读取状态、传输数据</li>
</ul>
</li>
<li>==设备驱动==: os中负责与设备交互的程序. 根据设备类型不同, 给每一类设备以统一的接口访问, 实现这个接口的就是设备驱动程序.</li>
<li>shell用read从0号文件描述符读入, 按下回车read返回</li>
</ul>
<ul>
<li><p>./hello如何被执行</p>
<ul>
<li>fork-execve</li>
<li>execve保留绝大部分进程状态,如文件描述符, 管道和重定向是改变文件描述符</li>
<li>sudo echo hello &gt; /etc/a没用的原因: 在execve之前open就已经失败了,还没有sudo</li>
</ul>
</li>
</ul>
<ul>
<li><p>==hello的第一条指令在哪里?==</p>
<ul>
<li>ld.so的_start()</li>
</ul>
</li>
<li><p>==hello的main函数执行之前, 系统中发生了什么?==</p>
<ul>
<li>加载器的$_$start, $_$init, 之后调用hello的 $_$start, $__$libc$_$start$_$main…</li>
</ul>
<p><img src="/figs/callgraph.png" alt="callgraph"></p>
<ul>
<li>gdb: starti <ul>
<li>发现在加载器的$_$start()(这是动态链接, 对于静态链接就是在程序里)</li>
</ul>
</li>
<li>info inferiors + pmap<ul>
<li>有hello, ld-xxx.so</li>
<li>没有看到libc代码</li>
</ul>
</li>
<li>b $_$start() + 再次pmap<ul>
<li>有了libc(加载器做的mmap)</li>
</ul>
</li>
<li>最后到main()</li>
<li>constructor函数: 可以在main之前执行</li>
<li>printf可能会被优化为puts</li>
</ul>
</li>
<li><p>printf()代码位置</p>
<ul>
<li>动态链接细节不考, 如got plt</li>
</ul>
</li>
<li><p>printf()是线程安全的吗?==如何实现线程安全的printf?==</p>
<ul>
<li>并发编程题目: <strong>条件变量</strong>, 信号量</li>
<li>复习生产者消费者问题</li>
</ul>
</li>
<li><p>printf字符串末尾没有换行:</p>
<ul>
<li>printf有libc的缓冲区<ul>
<li>setbuf(); fork的神坑(连缓冲区一起复制fork+printf两次, 6 or 8)</li>
<li>到文件:总是缓冲; 到中断: 换行</li>
</ul>
</li>
<li>ltrace有printf</li>
</ul>
</li>
<li><p>printf背后的系统调用: write</p>
</li>
<li><p>write写到哪: 文件描述符对应的文件, 例如一个设备/dev/ttyx, 或者是文件系统中的一个文件</p>
</li>
<li><p>==文件系统如何实现== ==FAT==, ==ext2==(inode)</p>
</li>
<li><p>==如何保护数据不受损坏==:</p>
<ul>
<li>把不可靠的磁盘变可靠: RAID; 奇偶校验允许一块盘坏; 校验位均匀分布在各个盘上</li>
<li>实现崩溃一致性: fsck, 日志</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/os期中复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/os期中复习/" itemprop="url">OS期中复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T14:38:50+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Hello-World的故事"><a href="#Hello-World的故事" class="headerlink" title="Hello World的故事:"></a>Hello World的故事:</h3><ul>
<li><p>Hello World的一生是从execve()开始的</p>
<ul>
<li>继承父进程的文件描述符(<code>./a.out &gt; /dev/null</code>; <code>./.a.out | cat</code>, …)</li>
<li>内核会为<code>a.out</code>创建代码、数据、堆栈</li>
</ul>
</li>
<li><p>执行的第一条指令</p>
<ul>
<li>从ELF的entry开始执行<ul>
<li>静态链接：<code>a.out</code>的entry</li>
<li>动态链接：<code>ld.so</code>的entry (动态链接器)</li>
<li>动态链接libc：链接器使用一系列mmap把libc链接进进程地址空间</li>
</ul>
</li>
</ul>
</li>
<li><p>main() 执行之前</p>
<ul>
<li><code>ld.so</code>会调用<code>_init()</code>；之后会调用<code>_start</code>, <code>__libc_start_main</code>, …<ul>
<li>但都是普通的“用户代码”，libc也是一个普通的C程序</li>
<li>完成整个C runtime的初始化，其中可能调用系统调用<ul>
<li>一个有趣的系统调用: ioctl, 判断是否是tty</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>main()的执行</p>
<ul>
<li>printf(…)<ul>
<li>如果有缓冲区，写入缓冲区 (fork会复制缓冲区)，否则直接用write写入<code>STDOUT_FILENO</code></li>
<li>如果缓冲区满足flush条件，则用write写入</li>
</ul>
</li>
</ul>
</li>
<li><p>main执行结束后，libc代码依然会执行(exit()也进行这些操作)</p>
<ul>
<li>调用<code>atexit()</code>注册的回调函数</li>
<li>清空缓冲区、释放资源</li>
<li>执行<code>_exit()</code>退出</li>
<li>如果结束前调用了_exit(), 则直接结束, 不进行上述操作</li>
</ul>
</li>
</ul>
<h3 id="进程-操作系统视角"><a href="#进程-操作系统视角" class="headerlink" title="进程: 操作系统视角"></a>进程: 操作系统视角</h3><ul>
<li>操作系统就是个中断处理程序<ul>
<li>系统启动时完成初始化</li>
<li>然后等待中断到来(打开中断，死循环或<code>yield()</code></li>
<li>在中断返回时，精心设计一个进程的上下文(context)<ul>
<li>在CR3寄存器中配置好虚拟内存的地址映射和权限</li>
<li>设置好寄存器的值：CS:EIP; SS:ESIP; …</li>
<li>执行<code>iret</code>让进程暂时占有CPU执行</li>
</ul>
</li>
</ul>
</li>
<li>“进程”只是操作系统中的一些数据，操作系统代码维护了代表“进程”的对象，以及和进程相关的对象<ul>
<li>进程上下文(寄存器的数值)</li>
<li>文件描述符(指向操作系统内对象的指针；文件访问的偏移量)</li>
<li>内存映射区域</li>
<li>进程的地址空间(页表、地址空间中的页面)</li>
</ul>
</li>
</ul>
<h3 id="重新理解系统调用"><a href="#重新理解系统调用" class="headerlink" title="重新理解系统调用"></a>重新理解系统调用</h3><ul>
<li><p>操作系统为用户进程提供的一组API，通常在内核空间中实现，实现用户进程对操作系统对象/物理硬件访问的请求。</p>
</li>
<li><p>在刚才的视角上理解系统调用</p>
<ul>
<li>进程 = 操作系统中的数据</li>
<li>系统调用 = 这些数据上的操作</li>
<li>例子：write()向某个操作系统的对象写入数据</li>
<li>例子：mmap()创建一个映射区域</li>
</ul>
</li>
<li><p>文件访问的偏移量问题:</p>
<ul>
<li>系统中所有以O_APPEND的文件描述符共享一个offset</li>
<li>每次单独的open都有一个独立的offset</li>
<li>fork()后父子进程在复制的文件描述符上共享一个offset</li>
</ul>
</li>
</ul>
<h3 id="操作系统与并发"><a href="#操作系统与并发" class="headerlink" title="操作系统与并发"></a>操作系统与并发</h3><ul>
<li>操作系统中的对象是在处理器之间共享的</li>
<li>多处理器系统：原子性、顺序、可见性的丧失</li>
<li>系统调用执行需要协调系统中的各个部分<ul>
<li>例子：read()管道时，需要等数据；write()管道时，需要等待管道的空位，否则阻塞</li>
<li>例子：read()终端时，需要等缓冲区中的数据；按下按键时，向缓冲区中写入数据</li>
<li>例子：使用DMA完成磁盘I/O，等待DMA中断的到来</li>
</ul>
</li>
<li>操作系统中有大量的同步问题<ul>
<li>条件变量</li>
<li>信号量</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/os并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/os并发/" itemprop="url">OS并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T14:38:46+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程threads"><a href="#线程threads" class="headerlink" title="线程threads"></a>线程threads</h2><p>pthread_create() 创立线程</p>
<p>pthread_join() 等待某线程结束</p>
<ul>
<li><strong>线程</strong>是操作系统能够进行运算调度的最小单位</li>
<li><strong>进程</strong>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位</li>
</ul>
<h3 id="顺序、原子性、可见性的丧失"><a href="#顺序、原子性、可见性的丧失" class="headerlink" title="顺序、原子性、可见性的丧失"></a>顺序、原子性、可见性的丧失</h3><ul>
<li><strong>原子性</strong>: 一个操作是不可中断的，要么全部执行成功要么全部执行失败. 即使单处理器, 也会因为操作系统中断而丧失.</li>
<li><strong>顺序性</strong>: 如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的</li>
<li><strong>可见性</strong>: 当一个线程修改了共享变量后，其他线程能够立即得知这个修改. 因为处理器的cache而丧失.</li>
</ul>
<p>因此需要锁.</p>
<h2 id="锁和条件变量的使用"><a href="#锁和条件变量的使用" class="headerlink" title="锁和条件变量的使用"></a>锁和条件变量的使用</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + <span class="number">1</span>; </span><br><span class="line"><span class="comment">// or whatever your critical section is</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有别的线程拥有这把锁, 那么当前线程得到锁, 继续运行;</p>
</li>
<li><p>如果别的线程持有该锁, 那么当前线程将一直等待直到得到锁.</p>
</li>
<li><p>锁初始化:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">assert(rc == <span class="number">0</span>); <span class="comment">// always check success!</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>pthread_cond_wait让线程睡眠, 等待其他线程发出信号</li>
<li>pthread_cond_signal唤醒正在沉睡中的对应线程</li>
<li>初始化: <ul>
<li>pthread_cond_init() </li>
<li>PTHREAD COND INITIALIZER</li>
</ul>
</li>
</ul>
<h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><h3 id="硬件层"><a href="#硬件层" class="headerlink" title="硬件层"></a>硬件层</h3><h4 id="LOCK指令"><a href="#LOCK指令" class="headerlink" title="LOCK指令"></a>LOCK指令</h4><ul>
<li><p>保证顺序, 原子性和可见性</p>
<h4 id="LL-SC"><a href="#LL-SC" class="headerlink" title="LL/SC"></a>LL/SC</h4></li>
<li><p>把一对读-写实现成一对“可能失败”的操作</p>
<ul>
<li><p>Load Linked (LL)：先执行一次读操作，并且在地址上做一个“标记”</p>
</li>
<li><p>Store Conditional (SC)：试探性地写入LL相同的地址(通过对内存地址获得独占访问)。如果LL-SC之间没有其他到该地址的写操作，则写入内存，返回SUCC；否则不执行写入(进而不会污染任何内存)，并返回FAIL。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3></li>
<li><p>开关中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lk)</span> </span>&#123;</span><br><span class="line">    pushcli();</span><br><span class="line">    <span class="keyword">while</span> (atomic_xchg(&amp;lk-&gt;locked, <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lk)</span> </span>&#123;</span><br><span class="line">    atomic_xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br><span class="line">    popsti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意ABBA类型, 不能过早地开中断. 可以将lock和unlock想成入栈和出栈的过程(处理器维护).<h3 id="能睡眠的互斥锁"><a href="#能睡眠的互斥锁" class="headerlink" title="能睡眠的互斥锁"></a>能睡眠的互斥锁</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>取消处理器空转, 在自旋失败的时候切换到别的线程执行</p>
</li>
<li><p>失败时将自己加入等待队列</p>
</li>
<li><p>有人释放锁时唤醒</p>
</li>
<li><p>例子: 游泳池的进入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flag;</span><br><span class="line">  <span class="keyword">int</span> guard; <span class="comment">// 持有guard锁才能更改flag</span></span><br><span class="line">  <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">    m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acqured</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue_add(m-&gt;q, gettid());</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>; <span class="comment">// 解锁</span></span><br><span class="line">    park(); <span class="comment">// 睡眠</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    unpark(queue_remove(m-&gt;q)); <span class="comment">// 唤醒</span></span><br><span class="line">  m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






</li>
</ul>
<h2 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h2><ul>
<li>最简单的做法: 每一个操作都上一把锁.</li>
<li>问题: 性能太差</li>
<li>计数器: 可用近似计数器, 每个CPU分别计数, 到达一个阈值就更新给全局计数器. </li>
<li>链表: 每次list一把大锁; 或者每个结点一把锁</li>
<li>队列: 头和尾各一把锁</li>
</ul>
<h2 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li><p>非常直观的同步方法：一个条件变量代表“某个条件满足”，支持：</p>
<ul>
<li><strong>等待</strong>某个条件满足后发生</li>
<li>某个条件满足，<strong>唤醒一个</strong>正在等待的线程</li>
<li>某个条件满足，<strong>唤醒所有</strong>正在等待的线程</li>
</ul>
</li>
<li><p>pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);<br>pthread_cond_signal(pthread_cond_t *c);唤醒一个</p>
<p>pthread_cond_broadcast(pthread_cond_t *c);唤醒所有</p>
</li>
<li><p><code>wait()</code>函数还需要一个<strong>互斥锁</strong>作为参数。<code>wait()</code>会解开锁并且让调用者进入睡眠状态（这是一个原子操作）。当调用者被唤醒时，<code>wait()</code>必须重新上锁，然后才能返回到调用者。</p>
</li>
<li><p>实现join</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  mutex_lock(&amp;mutex);</span><br><span class="line">  done[id] = <span class="number">1</span>; <span class="comment">// 可能和read并发执行</span></span><br><span class="line">  signal(&amp;joins);</span><br><span class="line">  mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; i++)</span><br><span class="line">    create(worker, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nworkers; i++) &#123;</span><br><span class="line">    lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span> (!done[i]) &#123;</span><br><span class="line">      wait(&amp;joins, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>如果删除了<code>done</code>：子线程先运行，父线程进入睡眠状态，永远无法唤醒。</p>
</li>
<li><p>如果删除了互斥锁：父线程获取数据的同时子线程修改了数据，产生竞争，父线程随即进入睡眠状态，永远无法唤醒。</p>
</li>
</ul>
<ul>
<li><p>注意: <strong>不要先signal再wait</strong></p>
</li>
<li><p>注意: <strong>wait前要上锁!!!</strong></p>
</li>
<li><p>signal建议在解锁之前</p>
</li>
</ul>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><ul>
<li><p>如果用一个信号变量, 会出现2个问题:</p>
<ul>
<li>问题1: 消费者C1因无商品休眠后, 被唤醒时, C2抢先清空了缓冲区, 但C1仍然认为有商品.<ul>
<li>问题关键: 没有确保唤醒了的线程立即执行.</li>
<li>解决方法: 将count的判断由if改为while.</li>
<li>解决的原因: wake up后马上check条件变量是否为1.</li>
<li>启示: 总是用<strong>while</strong>循环来处理条件变量, 多检查一次总是安全的!!!</li>
</ul>
</li>
<li>问题2: 消费者可能会唤醒消费者<ul>
<li>问题关键: 我们需要信号去唤醒线程，但信号的对象必须明确：消费者不能唤醒消费者，只能唤醒生产者，反之亦然。</li>
<li>解决方法: 用两个条件变量</li>
</ul>
</li>
</ul>
</li>
<li><p>生产者和消费者仍然需要支持并发性：需要多个商品缓冲区，可以一次生产/消费多个商品。</p>
</li>
<li><p>虚假唤醒: 反正用while就行.</p>
<p><img src="/figs/f1.png" alt="img"></p>
<p><img src="/figs/f2.png" alt="img"></p>
</li>
</ul>
<h2 id="信号量Semaphores"><a href="#信号量Semaphores" class="headerlink" title="信号量Semaphores"></a>信号量Semaphores</h2><ul>
<li><p>将生产者消费者问题中的互斥锁, 条件变量, 计数器合三为一.</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 第三个参数是初始值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// decrement the value of semaphore s by one</span></span><br><span class="line">  <span class="comment">// wait if value of semaphore s is negative</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// increment the value of semaphore s by one</span></span><br><span class="line">  <span class="comment">// if there are one or more threads waiting, wake one</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>信号量也是一个结构体<code>sem_t</code>，内部包含一个计数器<code>count</code>，它的行为是：</p>
<ul>
<li><p>P(原子)操作时，<code>count</code>减1，如果计数器数值小于零则线程睡眠等待</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">sem_t</span> &amp;sem)</span> </span>&#123;</span><br><span class="line">  sem-&gt;count--;</span><br><span class="line">  <span class="keyword">if</span> (sem-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    push(sem-&gt;<span class="built_in">queue</span>, current);</span><br><span class="line">    suspend();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>V(原子)操作时，<code>count</code>加一，同时如果有正在睡眠的线程，则把睡眠的线程唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">sem_t</span> &amp;sem)</span> </span>&#123;</span><br><span class="line">  sem-&gt;count++;</span><br><span class="line">  <span class="keyword">if</span> (!empty(sem-&gt;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    wakeup(pop(sem-&gt;<span class="built_in">queue</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>信号量 = 互斥锁 + 条件变量</p>
<ul>
<li>P/V是原子操作</li>
<li>仅有一个手环 = 互斥锁</li>
<li>P = wait; V = signal</li>
<li>因为计数器的存在，不会发生signal“丢失”(先signal再wait)</li>
<li>例子: 游泳池和手环</li>
</ul>
</li>
<li><p>实际上，信号量可以理解成一个锁(手环)的“池子”，计数器就是<strong>锁的数量</strong>。然后把P/V操作直观地理解：</p>
<ul>
<li>P操作就是从池子里取走一把锁。如果取成功，线程继续执行，如果取失败，就必须等待。</li>
<li>V操作就是把一把锁放进池子里。这时候如果有线程在等锁，那个线程可以取走这把锁执行。</li>
</ul>
</li>
<li><p>如果<code>count</code>的初始值为1，我们可以直接把P/V当作互斥锁来使用——池子里只有一把锁，进入临界区必须取得锁，临界区结束后归还。</p>
</li>
<li><p>一个简单的二元信号量锁的实现方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化信号量为1（书本原代码此处为问题）</span></span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量可用于等待其他进程</p>
</li>
<li><p>信号量解生产者消费者问题:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> empty = SEM_INIT(n);</span><br><span class="line"><span class="keyword">sem_t</span> fill = SEM_INIT(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;empty);</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">    V(&amp;fill);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;fill);</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br><span class="line">    V(&amp;empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意生产者消费者问题中的线程安全性. (printf是安全的)</li>
<li>解决方案：先等信号，再上锁。</li>
</ul>
</li>
<li><p>注意: P和V都不能被锁!!! 否则会死锁!!!</p>
</li>
<li><p>读写锁: 当一个线程想要获得第一把读锁时，它同时会获取写锁，直到它结束后才会释放写锁。这样，如果有线程想要获得写锁，就必须等待所有的读线程退出临界区。(性能垃圾)</p>
</li>
</ul>
<h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><ul>
<li>问题所在: 如何防止死锁</li>
<li>解决方案：<ol>
<li>增加一个管理者, 管理所有叉子</li>
<li>所有哲学家都先拿编号大的叉子(破坏环路)</li>
<li>上锁, 每次只有一个哲学家wait</li>
<li>只有拿起两支筷子的哲学家才可以进餐，否则，一支筷子也不拿。</li>
</ol>
</li>
</ul>
<h2 id="并发bugs"><a href="#并发bugs" class="headerlink" title="并发bugs"></a>并发bugs</h2><h3 id="死锁-ABBA"><a href="#死锁-ABBA" class="headerlink" title="死锁 (ABBA)"></a>死锁 (ABBA)</h3><ul>
<li><p>出现线程“互相等待”的情况</p>
</li>
<li><p>可能: spinlock不小心打开中断</p>
</li>
<li><p>死锁最基本的形式 (<strong>ABBA</strong>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1      tread2</span><br><span class="line">lock(A);</span><br><span class="line">             lock(B);</span><br><span class="line"></span><br><span class="line">lock(B); <span class="comment">// 阻塞</span></span><br><span class="line">             lock(A); <span class="comment">// 阻塞</span></span><br><span class="line"><span class="comment">// 任何线程都不能进入临界区</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在一个线程连续的两次lock之间发生另一个lock事件，死锁才会能触发。</p>
</li>
<li><p>例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_obj</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  spin_lock(&amp;lock[i]);</span><br><span class="line">  spin_lock(&amp;lock[j]);</span><br><span class="line">  arr[i] = <span class="literal">NULL</span>;</span><br><span class="line">  arr[j] = arr[i];</span><br><span class="line">  spin_unlock(&amp;lock[j]);</span><br><span class="line">  spin_unlock(&amp;lock[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时move_obj(1, 2)<code>;</code>move_obj(2, 1).</p>
</li>
</ul>
</li>
<li><p>死锁产生的四个条件 :</p>
<ul>
<li>互斥：一个资源每次只能被一个进程使用</li>
<li>请求与保持：一个进程请求资源阻塞时，不释放已获得的资源</li>
<li>不剥夺：进程已获得的资源不能强行剥夺</li>
<li>循环等待：若干进程之间形成头尾相接的循环等待资源关系</li>
</ul>
</li>
<li><p>AA型死锁非常容易检测</p>
</li>
<li><p>为了避免ABBA型的死锁</p>
<ul>
<li>任意时刻系统中的锁都是有限的</li>
<li>严格按照固定的顺序获得所有锁 </li>
<li>给上锁过程上个大锁</li>
</ul>
</li>
</ul>
<h3 id="原子性违反-ABA"><a href="#原子性违反-ABA" class="headerlink" title="原子性违反 (ABA)"></a>原子性违反 (ABA)</h3><ul>
<li>互斥锁(lock/unlock) - 原子性</li>
<li>忘记上锁——原子性违反 (Atomicity Violation, AV)</li>
</ul>
<h3 id="顺序违反-BA"><a href="#顺序违反-BA" class="headerlink" title="顺序违反 (BA)"></a>顺序违反 (BA)</h3><ul>
<li>条件变量(wait/signal) - 同步</li>
<li>忘记同步——顺序违反 (Order Violation, OV)</li>
<li>常见的情况：use after free</li>
</ul>
<h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><ul>
<li>数据竞争是两个共享内存访问，它们满足以下条件：<ul>
<li>访问同一个共享内存变量</li>
<li>发生在不同的线程</li>
<li>至少有一个是写</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/os持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/os持久化/" itemprop="url">OS持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T14:38:46+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h1><ul>
<li>磁: 磁铁方向, 磁盘</li>
<li>光: 挖坑填坑, 光盘</li>
<li>电: SSD</li>
<li>存储介质相当于是一个字节数组<code>bool bits[CAPACITY];</code></li>
</ul>
<h1 id="I-O设备与驱动"><a href="#I-O设备与驱动" class="headerlink" title="I/O设备与驱动"></a>I/O设备与驱动</h1><ul>
<li>I/O设备: 设备是三种操作的集合: <ul>
<li>(别人)发送命令(给他)、(别人)读取(他的)状态、(互相)传输数据</li>
</ul>
</li>
</ul>
<p><img src="/figs/iodev-model.png" alt="iodev-model"></p>
<ul>
<li><p>键盘: 按键信息会存储到键盘内置的缓冲数据区</p>
<ul>
<li><p>缓冲区通常大小是有限的</p>
</li>
<li><p>如果缓冲区满，后续按键将会丢失 (可能会发出声音)</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status = inb(<span class="number">0x64</span>);</span><br><span class="line"><span class="keyword">if</span> ((status &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// no input</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (status &amp; <span class="number">0x20</span>) &#123; <span class="comment">// mouse</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> code = inb(<span class="number">0x60</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// 按键的“扫描码”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>磁盘: 磁盘是一个巨大的bit array</p>
<ul>
<li><p>磁盘控制器: 配置好需要读/写的位置，然后开始传送数据</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">while</span> ((in_byte(<span class="number">0x1F7</span>)&amp;<span class="number">0xC0</span>) != <span class="number">0x40</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span> *dst, <span class="keyword">int</span> sect)</span> </span>&#123;</span><br><span class="line">  waitdisk();</span><br><span class="line">  out_byte(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// 读sector的数量</span></span><br><span class="line">  out_byte(<span class="number">0x1F3</span>, sect);</span><br><span class="line">  out_byte(<span class="number">0x1F4</span>, sect &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  out_byte(<span class="number">0x1F5</span>, sect &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  out_byte(<span class="number">0x1F6</span>, (sect &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">  out_byte(<span class="number">0x1F7</span>, <span class="number">0x20</span>);</span><br><span class="line">  waitdisk();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SECTSIZE / <span class="number">4</span>; i ++)</span><br><span class="line">    ((<span class="keyword">uint32_t</span> *)dst)[i] = in_long(<span class="number">0x1F0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>I/O设备: 实现</p>
<ul>
<li>CPU终究是通过地址和数据访问I/O设备的<ul>
<li>Port IO/MMIO只是两种不同的地址空间</li>
<li>电路负责根据地址把地址和数据“转发”给设备</li>
</ul>
</li>
</ul>
</li>
<li><p>显示加速器(显卡GPU)</p>
<ul>
<li>GPU是一个“协处理器”<ul>
<li>CPU可以将代码和数据传输给GPU</li>
<li>GPU执行程序，并且可以将程序的一部分输出绘制到屏幕上</li>
</ul>
</li>
</ul>
</li>
<li><p>管理I/O设备</p>
<ul>
<li>cat /proc/iomem: 得到IO的内存映射</li>
<li>lspci: 查看总线上的设备</li>
<li>lsblk: 查看块设备</li>
<li>“回路”设备<ul>
<li>可以把一个文件模拟成一个块设备</li>
<li>mount后在lsblk中可以看到</li>
</ul>
</li>
<li>用代码访问I/O设备：<ul>
<li>等待设备空闲</li>
<li>给设备发送数据和命令</li>
<li>等待设备完成命令</li>
</ul>
</li>
<li>拒绝忙等待: 利用中断机制<ul>
<li>在设备完成请求/发生变化时通知处理器</li>
<li>例子：磁盘可以配置成“命令完成后发送中断”</li>
<li>例子：再也不需要轮询键盘，有按键按下后会收到键盘中断</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象层: <strong>设备驱动</strong>(以Lab2为例)</p>
<ul>
<li><p>设备驱动: os中负责与设备交互的程序. 根据设备类型不同, 给每一类设备以统一的接口访问, 实现这个接口的就是设备驱动程序.</p>
</li>
<li><p>从系统启动后就一直存在</p>
</li>
<li><p>简化了很多(Plug and Play非常麻烦)</p>
</li>
<li><p>每个设备有三个操作：初始化、读、写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">device_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">devops</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> (*init)(<span class="keyword">device_t</span> *dev);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read)(<span class="keyword">device_t</span> *dev, <span class="keyword">off_t</span> offset, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write)(<span class="keyword">device_t</span> *dev, <span class="keyword">off_t</span> offset, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125; <span class="keyword">devops_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*init)();</span><br><span class="line">&#125; MODULE(dev);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>DMA：可以理解为实现<code>memcpy()</code>的I/O设备</p>
</li>
<li><p>性能不够, 处理器来凑</p>
</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h2><ul>
<li><p><strong>磁盘</strong> (I/O设备)：一个可以读/写的定长字节序列</p>
<ul>
<li>虚拟磁盘(文件)：一个可以读/写/的动态字节序列</li>
<li>可以理解成<code>std::vector&lt;uint8_t&gt;</code></li>
<li>类比<ul>
<li>进程 (虚拟CPU)：分时共享一个CPU</li>
<li>虚拟存储：多个虚拟地址空间</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件</strong>: 理解成一个名为xxx的<strong>虚拟存储设备</strong>(磁盘)，我们可以对这个虚拟磁盘中执行写入数据、扩展大小等操作</p>
</li>
<li><p><strong>目录directory</strong>: 文件/目录的集合</p>
<ul>
<li>目录体现了局部性：相关的数据存放在相近的目录</li>
<li>目录结构: 树形结构有助于帮我们分组<ul>
<li>人工训练的一个“决策树”</li>
<li>每个目录有<code>.</code> (当前目录)和<code>..</code> (上级目录)两个特殊的目录</li>
</ul>
</li>
</ul>
</li>
<li><p>目录/文件(inode)</p>
<ul>
<li>inode number: 索引数</li>
</ul>
</li>
<li><p><strong>文件系统</strong>是保存在持久存储上的数据结构</p>
<ul>
<li>数据结构在磁盘上的存储格式规范</li>
<li>允许对数据结构进行的操作</li>
<li>文件系统实现 = 数据结构的查询/修改操作<ul>
<li>可以通过文件管理进程(能够访问存储设备)实现</li>
</ul>
</li>
<li>文件系统基本操作<ul>
<li>目录操作：<ul>
<li>改变进程工作目录(chdir)、路径解析(当前目录pwd)</li>
<li>读取目录 (getdents)</li>
<li>目录操作 (link, unlink, rename, …)</li>
</ul>
</li>
<li>文件操作：<ul>
<li>打开(返回文件描述符)、关闭</li>
<li>文件描述符操作：read, write, lseek, ioctl, mmap, …</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件意义扩展: 操作系统中的一个可读/写/控制的<strong>对象</strong></p>
<ul>
<li>文件描述符：指向操作系统对象的handle(指向对象的指针)</li>
<li>read/write/ioctl系统调用 = 对象访问</li>
</ul>
</li>
<li><p><strong>虚拟文件系统</strong></p>
<ul>
<li>需要实现的需求:<ul>
<li>根据路径解析出操作系统中的对象 (磁盘文件、进程、操作系统配置、……)</li>
<li>open() → 解析路径、找到对象 → 对象自带read/write/…操作 → 创建文件描述符</li>
</ul>
</li>
<li>实现:<ul>
<li>把read/write翻译成对操作系统对象的读写, 包括进程/线程, 文件/目录, 设备, 其他数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><ul>
<li><p>procfs, sysfs都不是系统启动自带的，而是“<strong>挂载</strong>”的</p>
<ul>
<li>系统启动后仅有<code>/</code>, <code>/dev</code>，以及initramfs中的少量文件</li>
<li>init程序负责挂载其他部分(例如<code>/home</code>)</li>
</ul>
</li>
<li><p>挂载机制创建了文件系统世界：连接设备 - 文件系统实现 - 目录树</p>
<ul>
<li><code>mount -t type device dir</code></li>
</ul>
</li>
<li><p>系统中允许</p>
<ul>
<li>有多个文件系统根“/”，互相不可见<ul>
<li>chroot; 容器 (namespaces)<ul>
<li>chroot只影响路径解析, 如果持有外部文件描述符，则很容易jail break</li>
<li>如果“everything is a file”，所有可见的东西都在文件系统里，那么改变文件系统root就实现了完全的隔离</li>
</ul>
</li>
</ul>
</li>
<li>一份文件系统代码，多个设备/挂载点<ul>
<li>允许系统内有多个ext4分区</li>
<li>挂载多个procfs/sysfs (容器)</li>
</ul>
</li>
<li>把一个文件(例如.iso)挂载到文件系统中<ul>
<li>通过loopback device (类似于“虚拟光驱”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ul>
<li>目录也存储数据 (字节序列)，也是虚拟磁盘，因此目录和文件都用“inode”表示 (一个编号)</li>
<li>操作系统在路径解析、目录遍历时对它的数据有特殊的解读</li>
<li>实现方法：目录上有一些额外的操作<ul>
<li>lookup (路径解析)</li>
<li>create (创建文件)</li>
<li>link (链接)</li>
<li>unlink (删除)</li>
</ul>
</li>
<li>目录: 并不是树!</li>
<li>Linux系统允许创建两种类型的<strong>链接</strong><ul>
<li>硬链接：hard link<ul>
<li>目标只能是文件, 不能是目录</li>
<li>不能跨文件系统<ul>
<li>硬链接总是合法可以访问——能看到硬链接，说明文件系统被挂载</li>
</ul>
</li>
</ul>
</li>
<li>软(符号)链接：soft/symbolic link<ul>
<li>符号链接可以是任何相对/绝对路径<ul>
<li>只是一个“路径解析提示”</li>
<li>非常有用 &amp; 容易滥用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件管理：打开文件"><a href="#文件管理：打开文件" class="headerlink" title="文件管理：打开文件"></a>文件管理：打开文件</h3><ul>
<li>我们熟知的一系列API，访问各种文件：<ul>
<li>open(); read/write(); close();</li>
</ul>
</li>
<li>用这套API：<ul>
<li>访问磁盘上的数据</li>
<li>读取系统信息 (procfs)</li>
<li>配置操作系统 (sysfs)</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="打开目录"><a href="#打开目录" class="headerlink" title="打开目录"></a>打开目录</h3><ul>
<li>目录可以open但是不能read write</li>
<li>打开目录得到了一个指向文件系统某个位置的指针</li>
<li>对目录本身的操作<ul>
<li>fchmod, fchown, …</li>
</ul>
</li>
<li>相对于目录位置的操作<ul>
<li>openat()</li>
<li>linkat()</li>
</ul>
</li>
<li>更多的好处<ul>
<li>避免了每次open都解析路径 (有时路径很长)</li>
<li>在fd在合法的前提下，目录总是存在</li>
</ul>
</li>
</ul>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li><p>对同一个文件的多次操作是自然的</p>
<ul>
<li>文件描述符避免了每次操作都要重新打开文件</li>
<li>同时也帮助我们自动管理文件访问的偏移量</li>
</ul>
</li>
<li><p>内存映射方式访问</p>
<ul>
<li>适合随机访问的结构数据 (数据库)</li>
<li>mmap</li>
</ul>
</li>
<li><p>或read/write方式访问</p>
<ul>
<li>适合流式文件 (文件描述符托管了offset)</li>
</ul>
</li>
</ul>
<h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul>
<li>执行<code>sync</code>命令, 将缓存中磁盘操作都写入磁盘</li>
</ul>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><ul>
<li>文件系统是支持文件和目录操作的数据结构<ul>
<li>文件实现磁盘的虚拟化</li>
<li>目录实现文件的分类归档</li>
</ul>
</li>
</ul>
<h3 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h3><ul>
<li><p>块设备 = 固定大小的块(block)的数组 (存储设备)；支持：</p>
<ul>
<li>read(#blk, data)</li>
<li>write(#blk, data)</li>
<li>查看块大小<code>blockdev --getbsz /dev/sda2</code> (通常4KB) (通过sysfs得知)</li>
</ul>
</li>
<li><p>块设备API:</p>
<ul>
<li>进程/线程(通常是文件系统实现)向存储设备提交I/O request (block读/写)<ul>
<li>request首先进入设备的队列</li>
<li>经过调度器调度后，执行设备上的I/O (DMA)</li>
</ul>
</li>
<li>调度是为了<ul>
<li>保证多进程之间的公平性/优先级</li>
<li>I/O操作的合并</li>
</ul>
</li>
</ul>
</li>
<li><p>Block I/O调度</p>
<ul>
<li>I/O请求优化 + 兼顾进程优先级和公平<ul>
<li>例子：按照“电梯”方式寻道</li>
</ul>
</li>
<li>不该归操作系统管</li>
</ul>
</li>
</ul>
<h3 id="实现文件系统1-虚拟磁盘"><a href="#实现文件系统1-虚拟磁盘" class="headerlink" title="实现文件系统1: 虚拟磁盘"></a>实现文件系统1: 虚拟磁盘</h3><ul>
<li><p>文件 = 虚拟的磁盘</p>
<ul>
<li>数据块的数组，支持read, write, lseek操作</li>
<li>元数据 (大小固定)：大小、访问权限、修改时间……</li>
</ul>
</li>
<li><p>链表或树实现:</p>
<ul>
<li>只需要balloc()和bfree()</li>
</ul>
</li>
<li><p>在磁盘里划分一块专门的区域，每个bit代表每个块是否可用</p>
</li>
</ul>
<h3 id="实现文件系统2-目录文件"><a href="#实现文件系统2-目录文件" class="headerlink" title="实现文件系统2: 目录文件"></a>实现文件系统2: 目录文件</h3><ul>
<li><p>首先，假设系统里的每个文件(虚拟磁盘)都有唯一的编号(id)</p>
<ul>
<li>稍后我们讨论如何维护这个编号</li>
<li>目录 = 文件名 → 文件id的映射 (这个机制天然支持链接)</li>
</ul>
</li>
<li><p>目录也是文件</p>
<ul>
<li>用文件(虚拟磁盘)来存储key-value mapping</li>
<li>支持以下操作：<ul>
<li><code>value = get(key)</code> (路径解析)</li>
<li><code>set(key, value)</code> (link)</li>
<li><code>delete(key)</code> (unlink)</li>
<li><code>get_keys()</code> (遍历目录中的文件)</li>
</ul>
</li>
</ul>
</li>
<li><p>把虚拟磁盘看成<code>_heap = { start, end }</code></p>
<ul>
<li>实现目录文件就是OSLab1 (…)</li>
<li>额外需求：<code>get_keys()</code>, <code>get()</code>应当高效</li>
</ul>
</li>
</ul>
<h3 id="实现文件系统3-元数据inode"><a href="#实现文件系统3-元数据inode" class="headerlink" title="实现文件系统3: 元数据inode"></a>实现文件系统3: 元数据inode</h3><p>我们希望文件有</p>
<ul>
<li><p>唯一的一个编号</p>
</li>
<li><p>元数据</p>
<p>信息</p>
<ul>
<li>类型：是否为目录</li>
<li>数据：大小、权限、访问时间、链接数量</li>
<li>链表实现：链表的第一个块；树实现：索引块的编号</li>
</ul>
</li>
</ul>
<ul>
<li><p>UNIX：每个文件用一个inode (index node)表示</p>
<ul>
<li><code>ls -i</code>可以查看inode编号; <code>stat</code>查看文件元数据</li>
</ul>
</li>
<li><p>元数据inode的存储</p>
<ul>
<li><p>单独区域</p>
<ul>
<li>文件id = inode编号</li>
</ul>
</li>
<li><p>目录文件中</p>
<ul>
<li>文件id = 文件的第一块编号</li>
</ul>
</li>
<li><p>文件头部</p>
<ul>
<li>文件id = 文件的第一块编号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现文件系统"><a href="#实现文件系统" class="headerlink" title="实现文件系统"></a>实现文件系统</h2><ul>
<li>实现文件系统需要考虑以下因素：<ul>
<li>虚拟磁盘的数据结构 (链表、树、……)</li>
<li>目录文件的数据结构</li>
<li>inode的表示和存储</li>
<li>balloc/bfree的实现</li>
</ul>
</li>
</ul>
<h2 id="FAT和ext2"><a href="#FAT和ext2" class="headerlink" title="FAT和ext2"></a>FAT和ext2</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>实现文件: 链表, 为每一个block都维护一个“next block”<ul>
<li>链接存储在块尾</li>
<li>统一存储链接</li>
</ul>
</li>
<li>File Allocation Table文件分配表, 集中存储next<ul>
<li>next block占多少个字节？ FAT32 → 32bit (绝大部分信息都是32bit)</li>
<li>存储在文件系统头部, super block后</li>
</ul>
</li>
</ul>
<h3 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h3><ul>
<li><p>FAT文件系统的基本思想是使用链表管理所有的数据块。FAT文件系统把若干个连续的扇区(sector)作为一个簇(cluster)，也就是我们所说的管理存储的基本单位“块”，因此如果我们希望表示一个文件，我们只需要知道：</p>
<ul>
<li>文件的第一块的编号</li>
<li>对于每一块，它下一块的编号</li>
</ul>
<p>因此，FAT文件系统专门在磁盘中开辟一个区域(File Allocation Table, FAT)，来存储每一块的下一块编号。除了编号之外，还有两种特殊的编号：</p>
<ul>
<li>free (0, 该块可以使用)</li>
<li>EOF (-1, 该块代表了某个文件的末尾)</li>
</ul>
<p>这样，FAT还可以兼用于block bitmap，用于分配/回收数据块。</p>
</li>
<li><p>Partition Boot Record(PBR), 存储在分区的头部(例如<code>/dev/sda1</code>)</p>
</li>
<li><p>block”在FAT32中称为“sector”的“cluster” (簇)<img src="/figs/fat32-pbr.jpg" alt="fat32-pbr"></p>
</li>
<li><p>文件分配表</p>
</li>
</ul>
<p><img src="/figs/FAT32.png" alt="FAT32"></p>
<ul>
<li><p>FAT32目录项</p>
<ul>
<li>不支持链接; 因此inode(元数据)直接存储在目录项中</li>
<li>目录项直接按顺序存储在文件中</li>
<li>FAT16：11字节文件名(8文件名+3扩展名)；向前兼容<img src="/figs/fat32-dirent.png" alt="fat32-dirent"></li>
</ul>
</li>
<li><p>FAT如果损坏将会导致非常严重的后果</p>
<ul>
<li>相当于链表所有的“next”都丢失了</li>
<li>解决办法：多份FAT备份 (PBR)中指定了“number of FATs”</li>
<li>通常有两个副本，同时更新</li>
</ul>
</li>
<li><p>文件系统可能碎片化</p>
</li>
<li><p>磁盘碎片整理</p>
<ul>
<li>在磁盘中进行数据的“腾挪”</li>
<li>使文件尽可能在磁盘中占有连续的块</li>
</ul>
</li>
</ul>
<h3 id="ext2文件系统"><a href="#ext2文件系统" class="headerlink" title="ext2文件系统"></a>ext2文件系统</h3><ul>
<li><p>实现文件: 索引</p>
<ul>
<li><p>文件小的时候，立即能找到它的块</p>
</li>
<li><p>文件大的时候，才用索引</p>
<p><img src="/figs/ext2-inode.gif" alt="ext2-inode"></p>
</li>
</ul>
</li>
<li><p>支持链接，因此ext2单独管理inodes</p>
<ul>
<li>每个inode占用128B或256B空间 (相比FAT来说是很大的)<ul>
<li>相比于FAT来说，浪费少量空间</li>
</ul>
</li>
<li><code>tune2fs -l /dev/sda1</code> - 查看文件系统信息</li>
</ul>
</li>
</ul>
<p><img src="/figs/ext2-groups.png" alt="ext2-groups"></p>
<ul>
<li>为什么要分组？<ul>
<li>把分配分为成了两级 (组级、块级)<ul>
<li>不用管理全局的bitmaps (inode/block)</li>
</ul>
</li>
<li>一定程度的性能优化<ul>
<li>尽量把相近(例如同一个目录)的文件分配在同一个组里</li>
<li>尽量把同一个文件的数据块分配在同一个组里</li>
</ul>
</li>
<li>这个设计还使磁盘大小动态调整变得容易</li>
<li>对于小文件(12个块以内，4KB块是48KB)，直接索引，没有额外的空间开销</li>
<li>对于中等文件，只使用一级索引</li>
<li>对于更大的文件(但更少)，使用更多级别的索引</li>
</ul>
</li>
<li>与FAT类似，ext2的目录中按顺序存储其中文件/子目录的名字和inode编号。</li>
</ul>
<h3 id="我理解的FAT和ext2的区别"><a href="#我理解的FAT和ext2的区别" class="headerlink" title="我理解的FAT和ext2的区别:"></a>我理解的FAT和ext2的区别:</h3><ul>
<li>ext2的inode集中储存, 而FAT的存在目录项中, 因此不支持链接</li>
<li>对于单个文件, FAT是用链表链接的, 每一块的下一个存在文件分配表中; 而ext2是树状结构</li>
</ul>
<h1 id="持久数据可靠性"><a href="#持久数据可靠性" class="headerlink" title="持久数据可靠性"></a>持久数据可靠性</h1><h2 id="RAID-创建副本"><a href="#RAID-创建副本" class="headerlink" title="RAID: 创建副本"></a>RAID: 创建副本</h2><ul>
<li><p>廉价冗余磁盘阵列</p>
</li>
<li><p>把多个磁盘虚拟成一块磁盘</p>
</li>
<li><p>用两块磁盘(redundancy)实现容错</p>
<ul>
<li><code>read(blk)</code> -&gt; 从任何一块盘读即可</li>
<li><code>write(blk)</code> -&gt; 必须写入两块磁盘</li>
<li>实现了2X读速度</li>
<li>写速度不变</li>
<li>可以抵抗一块盘损坏 (只要磁盘没有连续损坏，就能实现容错)</li>
</ul>
</li>
<li><p>设计RAID，就是设计“如何把虚拟磁盘块映射到物理磁盘块”</p>
<ul>
<li>允许一对多映射; redundancy冗余</li>
<li>评价标准: capacity, reliablity, performance</li>
</ul>
</li>
</ul>
<h3 id="RAID-0-Striping-没有冗余"><a href="#RAID-0-Striping-没有冗余" class="headerlink" title="RAID-0(Striping) = 没有冗余"></a>RAID-0(Striping) = 没有冗余</h3><ul>
<li>无冗余, 不容错, 性能2X、容量2倍, 连续的块轮流分布在不同的Disk上(加快连续读写速度)</li>
<li>和chunk size有关, 小了读写的并行性增加, 但是跨越chunk读取可能性增加, 增加了access时间</li>
</ul>
<h3 id="RAID-1-mirror"><a href="#RAID-1-mirror" class="headerlink" title="RAID-1:(mirror)"></a>RAID-1:(mirror)</h3><ul>
<li><p>维护两块数据完全一样的磁盘实现容错</p>
</li>
<li><p>纠错码:</p>
<ul>
<li>无论有多少bit，只要至多只有1位错，我们就可以用1bit来纠错<ul>
<li>存储x, y, z, x\oplus y\oplus z<em>x</em>,<em>y</em>,<em>z</em>,<em>x</em>⊕<em>y</em>⊕<em>z</em></li>
<li>任何一个数值丢失，都能恢复出剩下的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RAID-4-奇偶校验"><a href="#RAID-4-奇偶校验" class="headerlink" title="RAID-4(奇偶校验)"></a>RAID-4(奇偶校验)</h3><table>
<thead>
<tr>
<th align="center">Block</th>
<th align="center">磁盘1</th>
<th align="center">磁盘2</th>
<th align="center">磁盘3</th>
<th align="center">磁盘4</th>
<th align="center">磁盘P</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">0⊕1⊕2⊕3</td>
</tr>
<tr>
<td align="center">#1</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">4⊕5⊕6⊕7</td>
</tr>
<tr>
<td align="center">#2</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="center">8⊕9⊕10⊕11</td>
</tr>
<tr>
<td align="center">#3</td>
<td align="center">12</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
<td align="center">12⊕13⊕14⊕15</td>
</tr>
</tbody></table>
<p>5块盘实现：</p>
<ul>
<li><p>顺序/随机读 4X加速</p>
</li>
<li><p>顺序写入依然可以4X</p>
</li>
<li><p>随机写入：</p>
<p>P<em>′=</em>P⊕D′⊕D(1的个数奇偶)</p>
<ul>
<li>需要读出D和P；计算后再写入</li>
<li>速度减半</li>
</ul>
</li>
<li><p>恢复一块盘: 其他盘异或</p>
</li>
</ul>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID-5"></a>RAID-5</h3><p>Parity盘是整个系统的瓶颈！因此将Party盘分散开.</p>
<table>
<thead>
<tr>
<th align="center">Block</th>
<th align="center">磁盘1</th>
<th align="center">磁盘2</th>
<th align="center">磁盘3</th>
<th align="center">磁盘4</th>
<th align="center">磁盘P</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">#1</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">P</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">#2</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">P</td>
<td align="center">10</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">#3</td>
<td align="center">12</td>
<td align="center">P</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
</tr>
</tbody></table>
<ul>
<li><p>顺序/随机读 4X加速</p>
</li>
<li><p>顺序写入依然4X</p>
</li>
<li><p>随机写入：</p>
<p><em>P</em>′=<em>P</em>⊕<em>D</em>′⊕<em>D</em></p>
<ul>
<li>依然需要2读2写</li>
</ul>
</li>
</ul>
<ul>
<li><p>理论分析</p>
<p>假设有n块组成RAID</p>
<table>
<thead>
<tr>
<th align="center">RAID</th>
<th align="center">容量</th>
<th align="center">容错</th>
<th align="center">顺序读</th>
<th align="center">随机读</th>
<th align="center">顺序写</th>
<th align="center">随机写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">n</td>
<td align="center">0</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">n/2</td>
<td align="center">1..n/2</td>
<td align="center">$&gt;$ n/2</td>
<td align="center">n</td>
<td align="center">n/2</td>
<td align="center">n/2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">n-1</td>
<td align="center">1</td>
<td align="center">n-1</td>
<td align="center">n-1</td>
<td align="center">n-1</td>
<td align="center">1/2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">n-1</td>
<td align="center">1</td>
<td align="center">n-1</td>
<td align="center">n</td>
<td align="center">n-1</td>
<td align="center">n/4</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="崩溃恢复和日志"><a href="#崩溃恢复和日志" class="headerlink" title="崩溃恢复和日志"></a>崩溃恢复和日志</h2><h3 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h3><ul>
<li>考虑在FAT上创建一个目录(mkdir)的Access Path：<ol>
<li>b $\leftarrow$ balloc()，读取FAT</li>
<li>FAT[b]$ \leftarrow$ EOF</li>
<li>写入b<em>b</em>为初始数据</li>
<li>追加写入目录文件 (假设目录文件需要一个额外的数据块)<ol>
<li>b’$ \leftarrow$ balloc()</li>
<li>写入目录文件</li>
<li>FAT[b’] $\leftarrow$ EOF</li>
<li>FAT[$d_{end}$] $\leftarrow$ b’</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="系统崩溃-原子性的丧失"><a href="#系统崩溃-原子性的丧失" class="headerlink" title="系统崩溃: 原子性的丧失"></a>系统崩溃: 原子性的丧失</h3><p>考虑更简单的例子：追加写(相当于写入目录文件)</p>
<ol>
<li>$FAT[b’] \leftarrow EOF$</li>
<li>$data[b’] \leftarrow$ 数据</li>
<li>$FAT[f_{end}] \leftarrow b’$</li>
</ol>
<p>等同于链表操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span> *<span class="title">blk</span> = <span class="title">balloc</span>();</span> <span class="comment">// 找到某个blk-&gt;next == FREE</span></span><br><span class="line">blk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">file_end-&gt;next = blk;</span><br><span class="line">write_data(blk);</span><br></pre></td></tr></table></figure>

<ul>
<li>考虑所有可能崩溃的情况 (去除重复)<ul>
<li>$data[b’] $→ ❌ (random writes)</li>
<li>$FAT[f_{end}]$ → ❌ (corrupted FAT)</li>
<li>$FAT[b’]$→ ❌ (dead block/leak)</li>
<li>$data[b’]$ → $FAT[f_{end}]$ → ❌ (random writes + corrupted FAT)</li>
<li>$FAT[b’]$→ $data[b’]$ → ❌ (dead block x 2)</li>
<li>$FAT[b’] $→ $FAT[f_{end}]$ → ❌ (corrupted file)</li>
<li>$FAT[f_{end}]$→ $FAT[b’]$ → $data[b’] $✅</li>
</ul>
</li>
</ul>
<p>对于ext2, 文件追加写(一块)，需要写入：</p>
<ol>
<li>inode (size、索引); 2. 数据bitmap; 3. 数据</li>
</ol>
<p>可能的崩溃情况：</p>
<ul>
<li>{1} - corrupted filesystem</li>
<li>{2} - dead block</li>
<li>{3} - random writes</li>
<li>{1,2}- incorrect data</li>
<li>{1,3} - corrupted filesystem</li>
<li>{2,3} - dead block</li>
</ul>
<h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><ul>
<li><p>功能: 发现不一致并修复</p>
</li>
<li><p>步骤:</p>
<ul>
<li>Superblock: <ul>
<li>检查superblock是否合理; 找到可能崩溃的superblock, 决定是否使用其备份</li>
</ul>
</li>
<li>Free blocks:<ul>
<li>扫描inodes, (double)indirect blocks等, 找到已经分配过的块.</li>
<li>如果allocation bitmaps和inodes不一致, 相信inodes</li>
<li>对于inodes进行同样的检查</li>
<li>inode state, inode links(计数), 备份, Bad blocks(指向非法区域的), 目录文件(尤其是.和..)</li>
</ul>
</li>
</ul>
<p>简略的为:</p>
<p>在文件操作时不管崩溃一致性，但在崩溃后扫描磁盘进行补救</p>
<ul>
<li>扫描inodes里的所有数据块，检查bitmap的一致性</li>
<li>检查inode数据是否“看起来合法”，否则删除</li>
<li>检查链接情况 (没有链接的inode被移到lost+found目录中)</li>
</ul>
</li>
</ul>
<h3 id="日志-write-ahead-logging-journaling"><a href="#日志-write-ahead-logging-journaling" class="headerlink" title="日志(write-ahead logging, journaling)"></a>日志(write-ahead logging, journaling)</h3><ul>
<li><p>更新磁盘前先记录所做操作</p>
</li>
<li><p>把操作以append only的方式记录下来</p>
<ul>
<li>先写入数据 (TXBegin和数据)；然后sync</li>
<li>写入TXEnd；再次sync</li>
</ul>
</li>
<li><p>用一个额外的指针维护journal完成的时刻</p>
<ul>
<li>journal write (写入TXBegin和数据)</li>
<li>journal commit (TXEnd + sync)</li>
<li>之后可以自由更新数据结构和指针 (完成后到达checkpoint)</li>
<li>procfs中有jbd的统计信息</li>
</ul>
</li>
<li><p>防止日志过长:</p>
<ul>
<li>circular log: 到达checkpoint后free</li>
</ul>
</li>
<li><p>恢复崩溃:</p>
<ul>
<li><p>从指针开始，向后重做journal中记录的操作</p>
<ul>
<li>(redo logging)</li>
<li>还有一种undo logging，记录操作的inverse (数据库中常用)</li>
</ul>
</li>
<li><p>Journaling实现了文件系统操作的原子性</p>
<ul>
<li>若干个block writes，要么全部发生，要么一个都不发生</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/os虚拟化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/os虚拟化/" itemprop="url">OS虚拟化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T13:55:30+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h2><ul>
<li>如果程序只完成“计算”的任务而不做任何输入输出，它就可以看成是一个状态机。程序的内存M和寄存器R构成了程序任意时刻的状态(M,R).</li>
<li>进程的机器状态：内存（地址空间）、寄存器（PC、IP、栈指针、帧指针等）、IO信息等。</li>
<li>每个线程有它自己的资源<ul>
<li><code>const char *name</code> - 它的名字</li>
<li><code>_Context context</code> - 保存的寄存器现场</li>
<li><code>char stack[4096]</code> - 堆栈</li>
</ul>
</li>
<li>进程 = 线程 + 地址空间</li>
</ul>
<h3 id="分时复用处理器"><a href="#分时复用处理器" class="headerlink" title="分时复用处理器"></a>分时复用处理器</h3><ul>
<li><p>只要我们能在某一个时刻，<strong>把M和R从处理器上拆下来，换上(M’,R’)</strong>.</p>
</li>
<li><p>把处理器“拆下来”的机制就是中断/系统调用。</p>
</li>
<li><p>操作系统实际从一开始就驻留在内存中，并且配置了中断处理程序的入口地址，一旦进程发生中断/异常/系统调用，操作系统代码就立即接手执行。</p>
</li>
<li><p>每个进程有自己的R, 因此需要寄存器现场的保存.</p>
</li>
</ul>
<h3 id="操作系统：实现虚拟化"><a href="#操作系统：实现虚拟化" class="headerlink" title="操作系统：实现虚拟化"></a>操作系统：实现虚拟化</h3><ul>
<li>现代计算机系统实现虚拟化里最重要的两个想法就是：<ol>
<li>使用虚拟地址空间VM让多个程序共享一个物理内存；</li>
<li>把(M,R)中寄存器现场R当做数据保存，并在寄存器现场R之间切换。</li>
</ol>
</li>
</ul>
<h3 id="管理应用程序有序执行"><a href="#管理应用程序有序执行" class="headerlink" title="管理应用程序有序执行"></a>管理应用程序有序执行</h3><ul>
<li>应用程序(进程)在计算时，没有任何权限访问不属于自己的内存</li>
<li>应用程序想从外界输入/输出任何信息、请求操作系统完成任何功能，都需要通过<strong>系统调用</strong></li>
</ul>
<h3 id="进程管理API"><a href="#进程管理API" class="headerlink" title="进程管理API"></a>进程管理API</h3><ul>
<li><code>fork()</code>:创建一个与当前进程几乎完全相同的进程(同样的地址空间、同样的内存数据)，为了区别新旧进程，父进程(执行<code>fork</code>的进程)返回被创建进程(子进程)的进程号(pid)，而子进程返回0。</li>
<li><code>execve(const char *path, char *argv[], char *envp[])</code>: 在不改变当前进程拥有资源的前提下，“替换”当前进程为<code>path</code>，并且调用<code>main(argc, argv, envp)</code>执行。除了地址空间被完全重建，很多进程拥有的操作系统相关状态都不发生改变：<ol>
<li>进程号(pid)不变；</li>
<li>文件描述符照用；</li>
<li>进程当前目录不变；</li>
<li>访问权限不变；</li>
<li>附属终端不变；</li>
<li>信号掩码不变；</li>
<li>……</li>
</ol>
</li>
<li><code>_exit()</code>结束进程的一生。注意<code>exit()</code>和<code>_exit()</code>是不同的，前者是libc提供的函数，而后者是操作系统提供的系统调用。在libc库中会执行一些额外的操作，例如执行<code>atexit()</code>注册的call backs，以及清空<code>printf</code>的缓冲区。</li>
<li>新建(create)；</li>
<li>销毁(destroy)：主动退出或者被杀死；</li>
<li>等待(wait)：等待进程直到运行结束；</li>
<li>混合操作(miscellaneous control)：睡眠、恢复等；</li>
<li>状态(status)：获得进程状态。</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul>
<li>简单来说，进程可能处于以下三个状态之一：<ul>
<li>Running：进程在处理器上执行指令；</li>
<li>Ready：进程准备执行，但由于某些原因OS决定现在不让它运行；</li>
<li>Blocked：进程此前执行了某些操作，让它在其他事件发生前停止执行。</li>
</ul>
</li>
<li>决定当前执行什么程序是系统调度的任务</li>
</ul>
<h3 id="直接执行限制"><a href="#直接执行限制" class="headerlink" title="直接执行限制"></a>直接执行限制</h3><ul>
<li>内核态和用户态</li>
<li>自陷, 系统调用</li>
<li>进程切换: <ul>
<li>等待系统调用; </li>
<li>利用时钟中断OS接管</li>
</ul>
</li>
<li>保存和恢复上下文</li>
</ul>
<h2 id="终端和Shell"><a href="#终端和Shell" class="headerlink" title="终端和Shell"></a>终端和Shell</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>File descriptor: 一个操作系统中打开的文件 (一个指向操作系统内对象的“指针”)<ul>
<li>stdin: 0, stdout: 1, stderr: 2</li>
<li><code>open()</code>会返回没有被占用的第一个文件描述符</li>
<li><code>int dup(int oldfd);</code> - 复制<code>oldfd</code></li>
<li><code>int dup2(int oldfd, int newfd);</code> - 关闭<code>newfd</code>，并复制<code>oldfd</code>到<code>newfd</code></li>
</ul>
</li>
</ul>
<h3 id="管道：进程间通信"><a href="#管道：进程间通信" class="headerlink" title="管道：进程间通信"></a>管道：进程间通信</h3><ul>
<li><p>lhs-cmd | rhs-cmd<code>: 运行</code>lhs-cmd<code>，把stdout连接到</code>rhs-cmd的stdin</p>
<ul>
<li><code>int pipe(int pipefd[2]);</code> 在操作系统中创建一个管道</li>
<li><code>pipefd[0]</code> - 读口；<code>pipefd[1]</code> - 写口</li>
</ul>
</li>
<li><p>默认情况下，管道是有限大小、blocking的</p>
<ul>
<li>管道满，write将等管道空出数据</li>
<li>管道空，read将等数据</li>
</ul>
</li>
<li><p><code>fork()</code> 不复制管道</p>
</li>
<li><p>Shell的主要功能是将执行命令的脚本翻译成系统调用的序列</p>
<ul>
<li><code>cmd &gt; file &lt; file</code> - 使用<code>fork-open-dup-execve</code></li>
<li><code>cmd1; cmd2</code>, <code>cmd1 &amp;&amp; cmd2</code>, <code>cmd1 || cmd2</code> - 按顺序执行</li>
<li><code>cmd1 | cmd2</code> - 使用<code>pipe-fork-dup-execve</code></li>
<li>预处理：<code>$()</code> - 创建一个shell，将输出重定向到管道中读出</li>
</ul>
</li>
</ul>
<h3 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h3><ul>
<li><p>在应用层实现的中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在程序执行到一半时“跳转”到某个函数执行</p>
</li>
<li><p>接收到Ctrl-C的终端驱动程序会给终端对应的<strong>进程组</strong>发送 <strong>SIGINT</strong></p>
<p>(所有进程都会收到)</p>
<ul>
<li>Shell也可以选择使用raw mode，读取Ctrl-C，然后使用<code>kill()</code>发送<code>SIGINT</code></li>
<li>此时shell还需要把其他输入转发给jobs (tmux的实现)</li>
</ul>
</li>
<li><p>Shell关闭时</p>
<ul>
<li>给所有jobs发送<code>SIGHUP</code> (hang up)，默认行为是结束进程</li>
<li>nohup就是忽略这个信号</li>
</ul>
</li>
</ul>
<h3 id="输出到终端和重定向到文件的区别"><a href="#输出到终端和重定向到文件的区别" class="headerlink" title="输出到终端和重定向到文件的区别"></a>输出到终端和重定向到文件的区别</h3><ul>
<li><p>输出到终端, 输出条件为: </p>
<ul>
<li>满1024字节/换行/程序结束/手动fflush/stdin的scanf</li>
</ul>
</li>
<li><p>输出重定向到文件, 输出条件为:</p>
<ul>
<li>程序结束</li>
</ul>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li><p><strong>周转时间</strong> turnaround time: </p>
<p>$$ T_{turnaround} = T_{completion} - T_{arrival}$$</p>
</li>
<li><p>First In, First Out(FIFO)</p>
<ul>
<li>在任务所需时间不同的时候效果很差</li>
<li>护卫效应(convoy effect)</li>
</ul>
</li>
<li><p>Shortest Job First (SJF)</p>
<ul>
<li>在长的任务先来的时候还是有很差</li>
</ul>
</li>
<li><p>Shortest Time-to-Completion First (STCF)</p>
<ul>
<li>每当新任务到来, 判断谁先完成, 调度最先完成的那个</li>
</ul>
</li>
<li><p><strong>响应时间</strong>response time:</p>
<p>$$T_{response} = T_{firstrun} − T_{arrival}$$</p>
</li>
<li><p>Round Robin (Good For Response Time)</p>
<ul>
<li>时间片time slice</li>
<li>每次花一段时间(time slice/scheduling quantum)执行一个任务，然后切换到队列的下一个任务。</li>
</ul>
</li>
<li><p>Incorporating I/O</p>
<ul>
<li>任务执行I/O操作时会被阻塞，直到I/O操作完成。如果进行硬件读写，就可能会导致几毫秒的等待。因此，调度算法必须在I/O操作出现时合理的切换到别的任务。</li>
<li>当I/O操作完成时，会产生硬件中断，此时OS接管并将发起请求的进程调回ready状态。</li>
</ul>
</li>
<li><p>Multi-level Feed-back Queue (MLFQ):</p>
<ul>
<li><p>2条规则: </p>
<ul>
<li><p>规则1: 如果A比B优先级高,就跑A</p>
</li>
<li><p>规则2: 如果AB优先级相同, 用RR</p>
</li>
</ul>
</li>
<li><p>优先级改变:</p>
<ul>
<li><p>规则3: 一个任务刚进入系统, 则最高优先级</p>
</li>
<li><p>规则4a: 一个任务用完了一整个时间片, 则降低优先级</p>
</li>
<li><p>规则4b: 一个任务在时间片用完之前放弃了CPU, 则优先级不变</p>
</li>
</ul>
</li>
<li><p>避免starvation:</p>
<ul>
<li>问题1：如果系统中有太多交互型的程序，他们的优先级高，会保持对CPU的占用，那么低优先级的程序就永远无法得到CPU时间(starve)</li>
<li>问题2: 进程的行为可能随时间改变，一个计算型程序可能会变为交互型程序。此时这个程序无法重新获得优先级，响应时间高。</li>
<li>规则5: 经过一段时间S, 系统中所有任务优先级提到最高</li>
</ul>
</li>
<li><p>避免用户恶意利用调度规则</p>
<ul>
<li>问题: 恶心人的用户会破坏调度算法的合理性(game the scheduler)，在时间截止前进程发起一个（不关心结果的）I/O请求来放弃CPU，就可以保持在同一个优先级队列中，获得更多的CPU时间。</li>
<li>改写规则4: 一旦一个任务用完了某个等级分配的所有时间, 优先级就降低.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Proportional-Share"><a href="#Proportional-Share" class="headerlink" title="Proportional Share"></a>Proportional Share</h2><ul>
<li><p>每个进程都有一定的tickets(彩票), 彩票越多中奖率越高, 用随机数来选择调度哪一个(中奖)</p>
</li>
<li><p>ticket currency: </p>
<ul>
<li>每个user给自己的进程发tickets, 按比例兑换成global ticket</li>
</ul>
</li>
<li><p>ticket transfer:</p>
<ul>
<li>一个进程暂时把自己的tickets给另一个进程</li>
<li>尤其出现于 client/server</li>
</ul>
</li>
<li><p>ticket inflation:</p>
<ul>
<li>一个进程可以暂时增加或者减少自己的彩票数.</li>
<li>仅适用于互相信任的进程之间</li>
</ul>
</li>
<li><p>stride scheduling: </p>
<ul>
<li>确定的.</li>
<li>不好, 因为有global state. 当一个新进程进入的时候，pass的初始值决定了它是否能够霸占CPU；而在彩票方法中，添加一个新进程并不会影响其他进程的执行。彩票方法更容易处理新的进程。</li>
</ul>
</li>
</ul>
<h3 id="The-Linux-Completely-Fair-Scheduler-CFS"><a href="#The-Linux-Completely-Fair-Scheduler-CFS" class="headerlink" title="The Linux Completely Fair Scheduler (CFS)"></a>The Linux Completely Fair Scheduler (CFS)</h3><ul>
<li><p>引入了<strong>virtual runtime(vruntime)</strong></p>
</li>
<li><p>进程运行的时候增加vruntime</p>
</li>
<li><p>每次选择vruntime最低的</p>
</li>
<li><p>切换进程的时间选择:</p>
<ul>
<li>sched_latency(48 ms): <ul>
<li>决定多久后考虑是否要切换</li>
<li>这个值 / 进程数 决定时间片的长度</li>
<li>进程过多会导致时间片太小</li>
</ul>
</li>
<li>min_granularity(6 ms):<ul>
<li>最小时间片长度</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Weighting (Niceness)</strong></p>
<ul>
<li>UNIX世界允许用户调整进程的优先级(nice)<ul>
<li>-20 (最高优先级)：非常不nice (是个坏人)</li>
<li>19 (最低优先级)：非常nice (是个礼让的好人)</li>
</ul>
</li>
<li>时间片长度按照weight加权</li>
<li>vruntime 增加速度和weight相关, weight越大, 时间流逝越慢.</li>
</ul>
</li>
<li><p>红黑树来了, 飘过</p>
</li>
<li><p>I / O 处理和长时间睡眠进程: 进程醒了以后, vruntime最小为运行进程的最小vruntime减一个定值</p>
</li>
</ul>
<h3 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h3><ul>
<li>进程是属于处理器的，只被某个处理器调度(最大化cache locality)</li>
<li>只有在workload imbalance的时候，才进行cross-core migration</li>
<li>Scheduling threads on a multicore machine is hard</li>
</ul>
<h2 id="虚存抽象"><a href="#虚存抽象" class="headerlink" title="虚存抽象"></a>虚存抽象</h2><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><ul>
<li>是一个函数 $f(x) \in [0,M)$<ul>
<li>把地址空间中的任何一个地址映射到另一个地址</li>
<li>任何指令访问地址 x (包括取指令)，经过地址翻译后访问 f(x)</li>
<li>访问未映射的页面 $f(x)=\bot$ 将会触发异常 (Segmentation Fault)</li>
</ul>
</li>
</ul>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ul>
<li><p>段 (segment)：仅允许几段连续的虚拟内存</p>
<ul>
<li>x86: GDT, LDT描述“段”的内存映射</li>
</ul>
</li>
<li><p>就是虚拟内存分成一个个段, 比如堆区, 栈, 代码, 分别映射到物理内存中的一段区域</p>
</li>
</ul>
<h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><ul>
<li>主要介绍free list:<ul>
<li>内存区域里面, 每一块空闲内存头上存着size和next, 已分配区域存size和魔数magic</li>
<li>malloc就是在free list中找到一块适宜的, 标记为已经分配</li>
<li>free就是将一块内存重新连回free list之中</li>
<li>malloc的时候有分裂, free的时候有合并</li>
</ul>
</li>
<li>buddy system:<ul>
<li>每一块内存都是2的幂次大小, 用线段树存</li>
</ul>
</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li><p>页 (page)：可以以页为单位自由映射</p>
<ul>
<li>x86: “页目录-页表”数据结构描述内存映射</li>
<li>内存越大，页表层数越多：PML4 (48bit)</li>
</ul>
</li>
<li><p>复习：</p>
<ul>
<li>MMU</li>
<li>多级页表</li>
<li>反置页表IPT<ul>
<li>我们实际希望的是在系统中创造多个地址空间$as$，并且维护$f_{as}(x)$</li>
<li>我们不如让硬件维护一个全局的hash table，计算$f(as, x)$</li>
</ul>
</li>
<li>TLB (Translation Lookaside Buffer); </li>
<li>page table entry (PTE)</li>
<li>physical page number(PPN), virtual page number(VPN)</li>
<li>valid bit, protection bit, present bit, dirty bit, reference bit</li>
</ul>
</li>
</ul>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><ul>
<li><p>操作系统应该如何为进程提供虚拟内存管理？因为<em>Everything is a File</em>，所以只要能把操作系统里的对象“映射”到进程地址空间，就足够了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; <span class="comment">// 映射</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot)</span></span>; <span class="comment">// 修改映射权限</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将文件fd从offset开始的length长度映射到进程地址空间中虚拟地址addr开始的部分</li>
<li>如果addr == NULL, os选一个地址</li>
<li>prot: 是否可读, 可写, 可执行</li>
<li>flags: 是否可共享, …</li>
<li>成功则返回指向映射区域的一个指针, 失败则返回(void *) -1.</li>
</ul>
</li>
<li><p>不映射任何文件(<code>fd=-1</code>, <code>MAP_ANONYMOUS</code>)，等同于内存分配 (<code>mmap</code>可以直接分配几十GB的内存；用户空间的内存分配是基于mmap实现的)</p>
</li>
<li><p>可以映射任何支持mmap的文件/设备</p>
<ul>
<li>ELF文件中间的那么多“空白”: 为了填满一页</li>
</ul>
</li>
<li><p>可以以各种权限(<code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code>)映射</p>
</li>
<li><p>操作系统会管理好一切(偶尔你需要<code>msync (2)</code>)</p>
</li>
<li><p>mmap并不需要真的映射</p>
<ul>
<li>操作系统只需要记下这一次mmap操作，并将页面标记为“不存在”</li>
<li>缺页时操作系统就“知道”该给这个页面填入什么值<ul>
<li>找到映射的文件</li>
<li>如果没有文件，直接返回一个全0的页面</li>
<li>如果有文件，从文件处读取数值</li>
<li>msync或页面回收时写回文件</li>
</ul>
</li>
<li>我们允许进程使用的内存大于物理内存</li>
<li>只要有一个大容量的设备，在物理内存紧缺时，swap out一些不常用的物理页(思考题：换出哪一页？)</li>
<li>缺页时再从设备换回</li>
</ul>
</li>
</ul>
<h3 id="fork-写时复制"><a href="#fork-写时复制" class="headerlink" title="fork: 写时复制"></a>fork: 写时复制</h3><ul>
<li>fork并不需要复制完整的<em>M</em></li>
<li>让父子进程只读共享所有页面；写时复制一份</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>它本质上就是个整数</li>
<li>在指针背后，实际是进程的“地址空间”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> value;</span><br><span class="line">*(<span class="keyword">char</span> *)value <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>value = 0</code> -&gt; Segmentation Fault</li>
<li>代码：只读、可执行</li>
<li>数据/堆栈：可读、可写、不可执行</li>
</ul>
<h3 id="静态链接程序的地址空间"><a href="#静态链接程序的地址空间" class="headerlink" title="静态链接程序的地址空间"></a>静态链接程序的地址空间</h3><ul>
<li><p>pmap查看</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00400000-004b6000                 r-xp  /tmp/a.out (代码)</span><br><span class="line">006b6000-006bc000                 rw-p  /tmp/a.out (数据)</span><br><span class="line">006bc000-006bd000                 rw-p  [bss](通过end查证)</span><br><span class="line">0131f000-01342000                 rw-p  [heap]</span><br><span class="line">7fff993c9000-7fff993ea000         rw-p  [stack]</span><br><span class="line">7fff993f4000-7fff993f7000         r--p  [vvar] </span><br><span class="line">7fff993f7000-7fff993f9000         r-xp  [vdso] </span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp  [vsyscall]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Virtual System Call: 系统调用，但不需要<code>int $0x80</code>/<code>sysenter</code></p>
<ul>
<li>gettimeofday/time</li>
<li>getcpu</li>
</ul>
<p>以上系统调用可以在只读内核数据的基础上实现</p>
<ul>
<li>时间：内核维护中断时的时间，用户程序加上rdtsc的结果</li>
<li>getcpu：为每个CPU上的进程映射不同的页面</li>
</ul>
</li>
<li><p>vvar, vdso: 加强版用户空间系统调用</p>
<ul>
<li>vvar: 3 pages (ro, 内核数据); vdso: 2 pages (rx, 统调用代码)</li>
<li>基本等于vsyscall</li>
<li>注意到它们的地址是紧接着堆栈的 (随机值)</li>
</ul>
</li>
</ul>
<h3 id="动态链接程序的地址空间"><a href="#动态链接程序的地址空间" class="headerlink" title="动态链接程序的地址空间"></a>动态链接程序的地址空间</h3><ul>
<li>启动动态链接器</li>
<li>装载所有需要的共享对象</li>
<li>重定位和初始化</li>
<li>ELF中入口点就是动态链接器</li>
<li>动态链接复习: GOT, PLT, …</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/启发性算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/启发性算法/" itemprop="url">启发性算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T11:59:49+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="启发性算法"><a href="#启发性算法" class="headerlink" title="启发性算法"></a>启发性算法</h1><ul>
<li>非常狭义定义：<ul>
<li>用来设计最优化问题的随机算法的鲁棒性技术；</li>
<li>不能保证解的效率和质量</li>
<li>没有有界常数概率</li>
</ul>
</li>
</ul>
<h2 id="模拟退火-Simulated-Annealing"><a href="#模拟退火-Simulated-Annealing" class="headerlink" title="模拟退火 Simulated Annealing"></a>模拟退火 Simulated Annealing</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>局部搜索+跳出局部最优的随机决策</p>
</li>
<li><p>局部搜索：找到一个可行解；找到邻域中的最优解替换并且循环这一步</p>
</li>
<li><p>多起点局部搜索</p>
</li>
<li><p>threshold local search：允许移动到较差解</p>
</li>
<li><p>模拟退火的基本思想:</p>
<pre><code>+  初始化：初始温度T，初始可行解$\alpha \in M(x)$(是算法迭代的起点)，温度关于温度和时间的下降函数f</code></pre><ul>
<li>时间$I=0$，当温度大于0(或不太靠近0)时，重复一下操作：<ul>
<li>随机选取$\alpha$邻域中的解$\beta$</li>
<li>如果$cost(\beta)\le cost(\beta)$, $\alpha:=\beta$; </li>
<li>否则生成一个(0, 1)间的随机数r<ul>
<li>如果$r&lt;\exp(-\frac{cost(\beta)-cost(\alpha)}{T})$, 则$\alpha:=\beta$; </li>
</ul>
</li>
<li>$I =I+1$</li>
<li>$T=f(T,I)$</li>
</ul>
</li>
</ul>
<ul>
<li>输出$\alpha$</li>
</ul>
</li>
</ul>
<h3 id="理论和经验"><a href="#理论和经验" class="headerlink" title="理论和经验"></a>理论和经验</h3><ul>
<li>如果下列条件成立, 模拟退火是渐进收敛的, 即取全局最优解的概率随迭代次数的增加趋向于1<ul>
<li>每个可行解都是任意其他可行解可达的</li>
<li>初始温度T至少为最深的非全局最优的局部最优解的深度</li>
</ul>
</li>
<li>初始温度选择:<ul>
<li>cost的最大差值</li>
<li>或者任选T, 过程中增大T值保证接受概率小于1</li>
</ul>
</li>
<li>温度下降函数选择:<ul>
<li>通常选取常数r, $0.8\le r \le 0.99$, $T := r\cdot T$</li>
<li>或者选取$T_k:=\frac{T}{\log_2(k+2)}$</li>
<li>每个固定温度的迭代次数d为邻域的大小</li>
</ul>
</li>
<li>终止条件:<ul>
<li>一段时间cost不变</li>
<li>T &lt; term, 通常$term\le \frac{\epsilon}{\ln [(|M(x)|-1)/p]}$</li>
</ul>
</li>
<li>观察结果:<ul>
<li>可能解质量好但是计算开销极大</li>
<li>解的质量实际上未必和初始解选取有关</li>
<li>最重要的参数是邻域和温度下降率</li>
<li>平均时间接近最坏时间</li>
<li>相同邻域下效果比局部搜索好</li>
</ul>
</li>
<li>应用: MAX-CUT, MIN-CUT; (TSP效果很差)</li>
</ul>
<h3 id="随机禁忌搜索"><a href="#随机禁忌搜索" class="headerlink" title="随机禁忌搜索"></a>随机禁忌搜索</h3><ul>
<li>模拟退火推广版</li>
<li>记录搜索过的最优解, 并且在邻域和TABU的差集中搜索, 搜索后更新TABU</li>
<li>TABU有多种选择策略, 可以前k步搜索过的解以免重复</li>
<li>随机禁忌搜索算法:<ul>
<li>选初始解$\alpha$, TABU = {$\alpha$}, STOP = FALSE, BEST = $\alpha$</li>
<li>选$Neigh_x(\alpha)-TABU$中最优解$\beta$, 同模拟退火选择是否接受$\beta$</li>
<li>更新TABU和STOP</li>
<li>重复直至STOP</li>
</ul>
</li>
</ul>
<h2 id="遗传算法-genetic-algorithm"><a href="#遗传算法-genetic-algorithm" class="headerlink" title="遗传算法 genetic algorithm"></a>遗传算法 genetic algorithm</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>遗传算法:</p>
<ul>
<li>创造一个初始化人口$P={\alpha_1, \cdots, \alpha_k}$; 已经创造的人口数$t=0$</li>
<li>计算fitness($\alpha_i$), i = 1, 2, …, k, 据此评估P的分布律$Prob_P$, 满足高fitness有较高概率</li>
<li>根据$Prob_P$随机选取$k/2$对可行解$(\beta_1^1, \beta_1^1)$, …, $(\beta_{k/2}^1, \beta_{k/2}^1)$</li>
<li>计算每一对的crossover生成新个体, 加入P</li>
<li>对P中每个个体随机使用变异mutation</li>
<li>对于P中每个个体再次计算fitness, 据此选择k个组成P’ $\subseteq$P</li>
<li>可能对于P’中元素在邻域中搜索最优解来替代</li>
<li>$t:=t+1$; $P:=P’$; 满足停止条件则输出, 不然重复上述步骤</li>
</ul>
</li>
<li><p>定义: M(x)的计划为任意向量$s=(s_1, s_2,…,s_n)\in \{0,1,* \} ^ n$(*表示free); 对于计划s的可行解集合为</p>
<p>$Schema(s_1, …, s_n) = \{ \gamma_1, …, \gamma_n\in M(x)|\gamma_i = s_i \text{ for all }i \in \{1,…,n\} $<br>$\text{ such that }s_i\in \{0,1\};\gamma_i \in\{0,1\}\text{ for all }j\in \{1,2,…,n \}\text{ such that }s_j=*  \}$</p>
</li>
<li><p>length(s): s中第一个和最后一个非*位置间的距离;</p>
<p>order(s): 非*位置数</p>
<p>$Fitness(s, P) = \frac{1}{|Schema(s)\cap P|}\cdot \sum_{\gamma\in Schema(s)\cap P}cost(\gamma)$</p>
<p>$Fit-ratio(s, P) = \frac{Fitness(s, P)}{\sum_{\beta \in P}cost(\beta)/|P|}$, 分母为平均fitness</p>
</li>
<li><p>The Schema Thm for GAS: 对任意Schema s 和任意 t= 1, 2, …, Schema(s)在(t+1)-st人口的期望个体数为</p>
<p>$E[Z_{t+1}]=Fit-ratio(s, P_t)\cdot \frac{n-length(s)}{n}\cdot (1-order(s)\cdot pr_m)\cdot |P_t\cap Schema(s)|$</p>
</li>
</ul>
<h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><ul>
<li><p>人口大小: </p>
<ul>
<li>太小容易局部最优, 太大计算开销大</li>
<li>30或者区间[n, 2n]内(n为实例的大小)</li>
</ul>
</li>
<li><p>初始人口选择:</p>
<ul>
<li>随机选择</li>
<li>选择较高质量的初始人口会增快收敛速度, 但容易收敛到局部最优</li>
</ul>
</li>
<li><p>fitness选择:</p>
<ul>
<li>最大化问题直接选取cost作为fitness, 或再减去一个小于最小值的常数; 减去的值越接近最小cost, 越偏向于高cost个体</li>
</ul>
</li>
<li><p>父母的选择:</p>
<ul>
<li>选最好的一半和剩下的随机组合</li>
<li>或者按照从小到大排序后, 根据$Prob(\alpha_i)=\frac{2i}{n(n+1)}$的概率选择</li>
</ul>
</li>
<li><p>个体的表示和crossover</p>
<ul>
<li>例如TSP中个体表示为1-n的排列, crossover可以选择为一个排列中的某部分按照另一个排列中的顺序重排</li>
<li>或者将父母的某些特征crossover, 然后选择满足crossover后性质的解作为孩子</li>
</ul>
</li>
<li><p>突变概率:</p>
<ul>
<li>1/100</li>
<li>或1/n</li>
<li>或$\frac{1}{k^{0.93}\sqrt{n}}$</li>
<li>如果人口数量k较小, 就要增大突变率防止局部最优</li>
</ul>
</li>
<li><p>新人口选择机制</p>
<ul>
<li>en block strategy: 孩子完全替代父母</li>
<li>elite model: 选一小部分父母中的高fitness个体, 其余的大部分选孩子</li>
<li>父母孩子放一起, 选择高fitness的</li>
<li>选完之后可以在小邻域中提升个体fitness</li>
</ul>
</li>
<li><p>停止策略:</p>
<ul>
<li>确定的代数</li>
<li>根据平均fitness(不怎么变)和个体差异(小)</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/随机算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/随机算法/" itemprop="url">随机算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T11:58:58+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>随机算法是非确定性算法, 但是可以看做一个额外有随机数序列作为输入的确定性算法.</p>
</li>
<li><p>随机算法的复杂度或者输出可以看做随机变量</p>
<ul>
<li>输出可以看做随机变量的随机算法称为<strong>蒙特卡洛算法</strong></li>
<li>永远输出正确答案但是复杂度是随机变量的随机算法称为<strong>拉斯维加斯算法</strong></li>
</ul>
</li>
<li><p>常常不知道随机化是否是有效的, 也不知道是否能在不牺牲资源的情况下转化为确定性算法.</p>
</li>
<li><p>可以结合随机算法和近似算法, 将近似率看做随机变量</p>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>$Random_A(x)$: 算法A在输入x的所有情况下的用到的最大随机比特数</p>
</li>
<li><p>$Random_A(n) = \max\{Random_A(x)| x ~is ~a ~input ~of ~size ~n\}$</p>
</li>
<li><p>$Prob_{A, x}(C)$: 算法A在输入x时以C的方式运行的概率</p>
<ul>
<li>是运行方式C中所有随机选择的概率之积</li>
</ul>
</li>
<li><p>$Prob(A(x) = y)$: 输入x时A输出y的概率</p>
</li>
<li><p>A在输入x时的期望运行时间<br>$$<br>Exp-Time_A(x)=E[Time]=\sum_CProb_{A,x}(C)\cdot Time(C)<br>$$</p>
</li>
<li><p>$$Exp-Time_A(n)=\max\{Exp-Time_A(x)|x ~is ~a ~input ~of ~size ~x\}$$</p>
</li>
<li><p>当期望时间难求的时候, 经常用最坏情况替代:</p>
<p>$$Time_A(x)=\max\{Time(C)|C ~is ~a ~run ~of ~A ~on ~x\}$$</p>
</li>
<li><p>$$Time_A(n)=\max\{Time_A(x)|x ~is ~a ~input ~of ~size ~x\}$$</p>
</li>
<li><p>但是随机算法允许小概率的永不终止</p>
</li>
</ul>
<h2 id="随机算法的分类"><a href="#随机算法的分类" class="headerlink" title="随机算法的分类"></a>随机算法的分类</h2><h3 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a><strong>拉斯维加斯算法</strong></h3><ul>
<li><p>永不给出错误输出</p>
</li>
<li><p>定义一: </p>
<p>如果对于问题$F$的所有输入实例$x$, 有<br>$$<br>Prob(A(x)=F(x))=1<br>$$<br>则随机算法A是拉斯维加斯算法. 其中的$F(x)$指在输入实例x时问题$F$的解.</p>
</li>
<li><p>定义二:</p>
<p>如果对于问题$F$的任何输入实例$x$, 有<br>$$<br>Prob(A(x)=F(x))\ge \frac{1}{2}<br>$$<br> 且<br>$$<br>Prob(A(x)=”?”)=1-Prob(A(x)=F(x))\le \frac{1}{2}<br>$$</p>
</li>
<li><p>随机快排: 每次随机选取一个数a, 将所有数分为大于a, 等于a, 小于a三类, 然后递归将小于a和大于a的类排序, 直到一类只有一个数.</p>
</li>
<li><p>类似的有随机算法求第k小的数</p>
<ul>
<li>期望运行时间</li>
</ul>
<p>$$<br>E(T(n))\le n-1 + \frac{1}{n}\sum_{j=1}^{n-1}\max(E(T_{j-1}, E(T_{n-j})))$$<br>$$\le n-1 + \frac{1}{n}\sum_{j=1}^{n-1}E[T_{max{j-1, n-j}}]$$<br>$$\le n-1 + \frac{2}{n}\sum_{l=\lceil n/2 \rceil}^{n-1}E[T_l]<br>$$</p>
</li>
</ul>
<ul>
<li>数学归纳法得$E(T(n))\le 5n$</li>
</ul>
<ul>
<li><p>拉斯维加斯单向通信:</p>
<ul>
<li>问题: <ul>
<li>$C_I$将输入x计算为一个prefix-free的01位串$\overline C_I(x)$</li>
<li>$C_{II}$根据$\overline C_I(x)$和y计算出0或者1</li>
<li>$Choice_n: {0,1}^n\times {1,2,\cdots,n}\to{0,1}: Choice_n(x_1x_2\cdots x_n,i)=x_i$</li>
<li>通过单向通信计算$Choice_n$ </li>
</ul>
</li>
<li>通信复杂度$\max{|\overline C_I(x)||x\in A_I}$至少为n</li>
<li>有如下$n / 2 + 1$拉斯维加斯算法:<ul>
<li>D1随机选择0或1</li>
<li>如果选到0, 发送$0x_1x_2\cdots x_{n/2}$, 否则发送$0x_{n/2+1}x_{n/2+2}\cdots x_{n}$</li>
<li>$r=0$时, 如果$j\in{1,2,\cdots,n/2}$, 输出$x_j$; 否则输出”?”;</li>
<li>$r=1$时, 如果$j\in{1,2,\cdots,n/2}$, 输出”?”; 否则输出$x_j$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单边错误蒙特卡洛算法"><a href="#单边错误蒙特卡洛算法" class="headerlink" title="单边错误蒙特卡洛算法"></a>单边错误蒙特卡洛算法</h3><ul>
<li><p>仅限于决定性问题</p>
</li>
<li><p>当算法A满足下列条件时, 称为单边错误蒙特卡洛算法</p>
<ul>
<li>对于所有$x\in L$, $Prob(A(x)=1)\ge \frac{1}{2}$</li>
<li>对于所有$x\not\in L$, $Prob(A(x)=0)=1$</li>
</ul>
</li>
<li><p>对于不符合要求的输入从不说”是”</p>
</li>
<li><p>例: 通过单向通信计算函数<br>$Non-Eq_n: \{0,1\}^n\times\{0,1\}^n\to \{0,1\}: Non-Eq_n(x,y)=1 ~iff ~x\ne y$</p>
<p>对于01位串u和v,  $u\ne v$ 说明$\overline C_I(u)\ne C_I(v)$</p>
<p>有如下$\log_2 n$单边错误蒙特卡洛算法:</p>
<ul>
<li>$R_I$随机选取一个[2, $n^2$]间的素数p(约$2\lceil\log_2 n\rceil$random bits)</li>
<li>$R_I$计算$s=Number(x)\mod p$, 发送$p$和$s$给$R_{II}$</li>
<li>$R_{II}$计算$q=Number(y)\mod p$, 如果$q\ne s$输出1, 否则输出0</li>
</ul>
</li>
<li><p>算法分析</p>
<ul>
<li>显然$Prob(R_I, R_{II} ~ rejects ~(x,y))=1$</li>
<li>若$x\ne y$但$Number(x)\mod p =Number(y) \mod p$<br>那么$p| h= |Number(x)-Number(y)|$</li>
<li>因为$h&lt;2^n$, 所以至多$n-1$个满足要求的素数l, 而区间内总共有至少$n^2/\ln_n^2$个素数,<br>所以概率至多为$\frac{n-1}{n^2/\ln_n^2}\le \frac{\ln n^2}{n}$. </li>
<li>因此$Prob((R_I, R_{II})~ accepts ~ (x,y))\ge 1-\frac{\ln n^2}{n}$, 当$n&gt;100$时大于0.9</li>
</ul>
</li>
</ul>
<h3 id="双边错误蒙特卡洛算法"><a href="#双边错误蒙特卡洛算法" class="headerlink" title="双边错误蒙特卡洛算法"></a>双边错误蒙特卡洛算法</h3><ul>
<li><p>定义: 对问题F的所有输入实例$x$, 存在$\epsilon(1&lt;\epsilon\le \frac{1}{2})$满足$Prob(A(x)=F(x))\ge \frac{1}{2} +\epsilon$</p>
</li>
<li><p>让算法A跑t次, 取其中至少出现$\lceil t/2\rceil$的结果(如果存在, 否则输出”?”), 算法记做$A_t$. 假设A跑一次正确概率为$p(x)\ge \frac{1}{2}+\epsilon$, 那么对于x, A跑k次给出正确答案的概率$Prob(A_t(x)=F(x))\ge 1-\frac{1}{2}(1-4\epsilon^2)^{t/2}$</p>
</li>
<li><p>如果要$Prob(A_k(x)=F(x))\ge 1-\delta$, 那么需要$k\ge \frac{2\ln 2\delta}{\ln(1-4\epsilon^2)}$</p>
</li>
</ul>
<h3 id="无界错误蒙特卡洛算法"><a href="#无界错误蒙特卡洛算法" class="headerlink" title="无界错误蒙特卡洛算法"></a>无界错误蒙特卡洛算法</h3><ul>
<li><p>定义: 对问题F的所有输入实例$x$, 有$Prob(A(x)=F(x))&gt; \frac{1}{2} $</p>
</li>
<li><p>想要通过运行k次无界错误蒙特卡洛算法A得到满足$Prob(A_{k(|x|)}(x)=F(x))\ge 1-\delta$的算法$A_{k(n)}$, 需要接受$Time_{A_{k(n)}}(n)=O(2^{2Random_A(n)}\cdot Time_A(n))$</p>
</li>
</ul>
<h3 id="随机最优化算法"><a href="#随机最优化算法" class="headerlink" title="随机最优化算法"></a>随机最优化算法</h3><ul>
<li><p>取最好的那次</p>
</li>
<li><p>$Prob(A_k(x)\in Output_U(x))=1-[Prob(A(x)\not\in Output_U(x))]^k$</p>
</li>
<li><p>定义: U的<strong>随机$\delta-$近似算法</strong>: 对于所有$x\in L_I$有</p>
<ul>
<li>$Prob(A(x)\in M(x))=1$</li>
<li>$Prob(R_A(x)\le \delta)\ge 1/2$</li>
</ul>
</li>
<li><p>类似的有<strong>随机f(n)-近似算法</strong>($\delta$改为$f(|x|)$)</p>
</li>
<li><p><strong>RPTAS</strong>: 对于任意输入对$(x,\delta)\in L_I \times \mathbb R^+$</p>
</li>
<li><p>对于所有随机选择, A计算出U的一个可行解: $Prob(A(x,\delta)\in M(x))=1$</p>
<ul>
<li>至少有1/2的概率输出一个相对误差至多$\delta$的可行解: $Prob(\epsilon_A(x,\delta)\le \delta)\ge 1/2$</li>
</ul>
</li>
<li><p>$Time_A(x, \delta^{-1})\le p(|x|,\delta^{-1})$, p是|x|的多项式函数</p>
</li>
<li><p>如果时间还是$\delta^{-1}$的多项式函数, 那么是<strong>RFPTAS</strong></p>
</li>
<li><p><strong>随机$\delta-$期望近似算法</strong>: 对所有$x\in L_I$</p>
<ul>
<li>$Prob(A(x)\in M(x))=1$</li>
<li>$E[R_A(x)]\le \delta$</li>
</ul>
</li>
</ul>
<h2 id="随机算法设计范式"><a href="#随机算法设计范式" class="headerlink" title="随机算法设计范式"></a>随机算法设计范式</h2><ul>
<li><p>随机算法打败对手策略中的”难”的输入</p>
</li>
<li><p>随机选取构造证书</p>
</li>
<li><p>指纹识别判断问题等价性</p>
<ul>
<li>随机选取映射h</li>
<li>计算指纹$h(R_1), h(R_2)$</li>
<li>如果$h(R_1)= h(R_2)$输出yes, 否则输出no</li>
</ul>
</li>
<li><p>随机采样</p>
<ul>
<li>随机变量的期望保证至少一个样本不大于期望, 至少一个样本不小于期望</li>
<li>样本以正概率满足某性质, 则一定有样本满足该性质</li>
</ul>
</li>
<li><p>松弛和随机舍入</p>
<ul>
<li>如整数规划-&gt;线性规划</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/近似算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XY's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/近似算法/" itemprop="url">近似算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T11:58:19+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>提供不比最优解差太多的可行解</p>
</li>
<li><p>定义: 对于最优化问题 $U = \{\Sigma_I, \Sigma_O, L, L_I, M, cost, goal\}$ , A是U的一个一致性算法. 对于所有问题实例$x\in L_I$, A对于x的相对误差$\epsilon_A(x)$定义为<br>$$<br>\epsilon_A(x) = \frac{|cost(A(x)) - Opt_U(x)|}{Opt_U(x)}<br>$$<br>其中, $Opt_U(x)$是x的最优cost.</p>
</li>
<li><p>对于任意$n\in \mathbb{N}$, 我们定义A的相对误差为<br>$$<br>\epsilon_A(n) = \max\{\epsilon_A(x)| x \in L_I \cap (\Sigma_I)^n\}<br>$$</p>
</li>
<li><p>A关于x的近似率$R_A(x)$定义为</p>
</li>
</ul>
<p>$$<br>R_A(x) = \max\{\frac{cost(A(x))}{Opt_U(x)}, \frac{Opt_U(x)}{cost(A(x))}\}<br>$$</p>
<ul>
<li><p>对于任意$n\in \mathbb{N}$, 我们定义A的相对近似率为<br>$$<br>R_A(x) = \max\{R_A(x)| x \in L_I\cap(\Sigma_I)^n\}<br>$$</p>
</li>
<li><p>对于任意正实数$\delta&gt;1$, 如果对任意$x\in L_I$, $R_A(x)\le \delta$, 定义A为U的<strong>$\delta-$近似算法</strong>.</p>
</li>
<li><p>对于任意函数$f:\mathbb{N}\to \mathbb{R^+}$, 如果对任意$n \in \mathbb{N}$, $R_A(x)\le f(n)$, 定义A为U的<strong>$f(n)-$近似算法</strong>.</p>
</li>
<li><p>对于最小化问题, 有</p>
</li>
</ul>
<p>$$<br>R_A(x) = \frac{cost(A(x))}{Opt_U(x)}=1 + \epsilon_A(x)<br>$$</p>
<ul>
<li><p>对于最大化问题, 有<br>$$<br>R_A(x) = \frac{Opt_U(x)}{cost(A(x))}<br>$$</p>
</li>
<li><p>Greedy Makespan Schedule:</p>
<ul>
<li><p>对于处理时间$p_i$排序, 从最大的开始, 依次将每个任务分配给最先空闲的机器.</p>
</li>
<li><p>证明这个算法是MS的2-近似算法:</p>
<ul>
<li><p>$I = (p_1, p_2, \cdots, p_n, m)$, $p_1&gt;p_2&gt;\cdots&gt;p_n$, 显然有<br>$$<br>Opt_{MS}(I) \ge p_1\ge p_2 \ge \cdots \ge p_n<br>$$<br>还有<br>$$<br>Opt_{MS}(I) \ge \frac{\sum_{i=1}^np_i}{m}<br>$$</p>
</li>
<li><p>对于任意$k = 1, 2, \cdots, n$, 因为$p_k$是$p_1$到$p_k$中最小的, 所以有<br>$$<br>p_k \le \frac{\sum_{i=1}^k p_i}{k}<br>$$</p>
</li>
<li><p>分类讨论:</p>
<ul>
<li><p>当$n\le m$时, 显然</p>
</li>
<li><p>当$n&gt;m$时, 设$T_l$满足$cost(T_l)=\sum_{r\in T_l}p_r = cost(GMS(I))$, 而k是$T_l$中最大的下标</p>
<ul>
<li><p>如果$k\le m$, $|T_l|=1$, 所以$Opt_{MS}(I) = p_1 = p_k$, $GMS(I)$是最优解.</p>
</li>
<li><p>如果$k&gt;m$, 因为其他机器的cost肯定不小于$cost(GMS(I)) - p_k$, 不然$p_k$就不会安排在这个机器, 所以<br>$$<br>\sum_{i=1}^{k-1}p_i\ge m\cdot [cost(GMS(I)) - p_k]<br>$$<br>再根据上面的式子2, 有<br>$$<br>Opt_{MS}(I)\ge cost(GMS(I))-p_k<br>$$<br>因此<br>$$<br>cost(GMS(I)) - Opt_{MS}(I)\le p_k\le \frac{\sum_{i=1}^k p_i}{k}<br>$$<br>最终有<br>$$<br>\frac{cost(GMS(I)) - Opt_{MS}(I)}{Opt_{MS}(I)}\le \frac{(\sum_{i=1}^k p_i)/k}{(\sum_{i=1}^n p_i)/m}\le \frac{m}{k} &lt; 1<br>$$<br>因此GMS是MS的2-近似算法.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定义: 对于最优化问题 $U = {\Sigma_I, \Sigma_O, L, L_I, M, cost, goal}$ , 如果对于所有的输入对$(x, \epsilon)\in L_I\times \mathbb{R^+}$, A可以计算出一个相对误差不大于$\epsilon$的可行解A(x), 而且$Time_A(x, \epsilon^{-1})$有$|x|$的多项式函数上界, 那么A被称为U的<strong>多项式时间近似方案(PTAS)$</strong>.而如果$Time_A(x, \epsilon^{-1})$有$|x|$和$\epsilon^{-1}$的多项式函数上界, 那么A被称为U的<strong>完全多项式时间近似方案(FPTAS)$.</strong></p>
</li>
<li><p>PTAS: 任意输入, 想要多小误差都可以在|x|线性时间求解. </p>
<p>FPTAS: 任意输入, 想要多小误差都可以在|x|和$\epsilon^{-1}$线性时间求解(误差越小越慢)</p>
</li>
</ul>
<h2 id="最优化问题分类"><a href="#最优化问题分类" class="headerlink" title="最优化问题分类"></a>最优化问题分类</h2><ul>
<li><p>NPO问题可以分为下列5类:</p>
<ul>
<li>NPO(I): 存在FPTAS的NPO最优化问题<ul>
<li>例如背包问题</li>
</ul>
</li>
<li>NPO(II): 存在PTAS的NPO最优化问题<ul>
<li>例如Makespan Schedule</li>
</ul>
</li>
<li>NPO(III):  $U\in NPO$满足<ul>
<li>存在$\delta &gt; 1$, 有多项式时间$\delta-$近似算法</li>
<li>没有PTAS. (即存在$d&lt;\delta$, U无$d-$近似算法)</li>
<li>例如最小顶点覆盖, $\Delta-$TSP, MAX-SAT</li>
</ul>
</li>
<li>NPO(IV): $U\in NPO$满足<ul>
<li>存在多项式时间$f(n)$近似算法, 且f有多项式上界</li>
<li>在某些假设下, 不存在任何$\delta-$近似算法</li>
</ul>
</li>
<li>NPO(V): $U\in NPO$满足对于所有可能存在的$f(n)-$近似算法, $f(n)$都没有多项式上界<ul>
<li>例如TSP, 最大团</li>
</ul>
</li>
</ul>
</li>
<li><p>在$P\ne NP$的前提下, 每一类都非空</p>
</li>
</ul>
<h2 id="近似算法的稳定性"><a href="#近似算法的稳定性" class="headerlink" title="近似算法的稳定性"></a>近似算法的稳定性</h2><ul>
<li><p>一般认为NPO(V)中的问题是不可求解的, 但是可以将$U\in NPO(V)$的输入$L_I$根据难度划分.</p>
</li>
<li><p>对于最优化问题 $U = \{\Sigma_I, \Sigma_O, L, L_I, M, cost, goal\}$ 和 $\overline U = \{\Sigma_I, \Sigma_O, L, L, M, cost, goal\}$ , $L_I\subseteq L$, $\overline U$关于$L_I$的<strong>距离函数</strong>$h_L:L\to \mathbb{R^{\ge 0}}$满足如下性质:</p>
<ul>
<li>对于所有$x\in L_I$, 有$h_L(x)=0$</li>
<li>h是多项式时间可计算的</li>
</ul>
</li>
<li><p>对于$\overline U$关于$L_I$的距离函数$h$, 对于任意$r\in \mathbb{R}$, 定义<br>$$<br>Ball_{r,h}(L_I) = \{w\in L| h(w)\le r\}<br>$$</p>
</li>
<li><p>A是$\overline U$的一致性算法, 也是$U$的$\epsilon-$近似算法($\epsilon \in \mathbb{R^{&gt;1}}$). 令p为正实数, 当对于所有实数$0&lt;r\le p$, 存在$\delta_{r, \epsilon}\in \mathbb{R^{&gt;1}}$满足A是$U_r= \{\Sigma_I, \Sigma_O, L, Ball_{r,h}(L_I), M, cost, goal\}$的$\delta_{r, \epsilon}-$近似算法, 我们定义<strong>A关于h是p-稳定的</strong> </p>
</li>
<li><p>如果对于所有正实数p, A都是p-稳定的, 那么A关于h是<strong>稳定</strong>的; 如果对于任意正实数p, A都不是p-稳定的, 那么A关于h是<strong>不稳定</strong>的</p>
</li>
<li><p>TSP和$\Delta-$TSP:</p>
<ul>
<li><p>对于任意输入实例(G, c), 定义<br>$$<br>dist(G,c)=\max\{0, \max\{\frac{c({u, v})}{c({u, v})+c({p,v})}-1|u, v, p\in V(G), u\ne v, u\ne p, v\ne p   \}\}<br>$$</p>
<p>$$<br>dist_k(G,c)=\max\{0, \max\{\frac{c({u, v})}{\sum_{i=1}^m c({p_i,p_{i+1}})}-1|u, v\in V(G), u=p_1, p_2, \cdots, p_m=v$$<br>$$\text{ is a simple path between u and v of length at most }k(m + 1\le k)    \}\}<br>$$</p>
<p>对于任意整数$k&gt;2$,<br>$$<br>distance(G,c) = \max\{disk_k(G,c)|2\le k\le|V(G)|-1  \}<br>$$<br>$Ball_{r, dist}(L_\Delta)$包含满足下面条件的带权图<br>$$<br>c({(u,v)})\le (1+r)(c({(u,p)}) + c({(p,v)}))<br>$$</p>
</li>
</ul>
</li>
<li><p>只有在h合理划分问题实例的时候才是有意义的</p>
</li>
<li><p>U和$\overline U$, h, $U_r$定义同上, 令$A={A_\epsilon}_{\epsilon&gt;0}$是U的一个PTAS</p>
<ul>
<li><p>如果对所有的$r&gt;0$和$\epsilon&gt;0$, $A_\epsilon$是一个$U_r $的$\delta_{r,\epsilon}-$近似算法, 那么A关于h是<strong>稳定</strong>的</p>
</li>
<li><p>如果$\delta_{r,\epsilon}\le f(\epsilon)\cdot g(r)$, 其中</p>
<ul>
<li>f和g是从$\mathbb R^{\ge 0}$到$\mathbb {R^+}$的函数, </li>
<li>$\lim_{\epsilon\to 0}f(\epsilon) = 0$</li>
</ul>
<p>那么A关于h是<strong>超稳定</strong>的</p>
</li>
</ul>
</li>
</ul>
<h3 id="对偶近似算法"><a href="#对偶近似算法" class="headerlink" title="对偶近似算法"></a>对偶近似算法</h3><ul>
<li><p>当限制条件不明确时, 可以找一个不比$Opt_U(I)$差的解, 允许$S\not\in M(I)$, 但是S离M(I)”不太远”</p>
</li>
<li><p>对于最优化问题U, 定义<strong>限制条件距离函数</strong>为满足如下性质的函数$h: L_I \times \Sigma^*_O\to \mathbb R^{\ge 0}$</p>
<ul>
<li><p>对于$S\in M(x)$, $h(x, S)=0$</p>
</li>
<li><p>对于$S\not\in M(x)$, $h(x, S)&gt;0$</p>
</li>
<li><p>h是多项式时间可计算的</p>
</li>
</ul>
</li>
<li><p>例如01背包问题中, 定义<br>$$<br>h(I, T)=\max\{0, \max\{\sum_{l\in T_i}p_l|i=1,2,…,m  \}-1\}<br>$$<br>如果存在$\epsilon$满足对任何$i=1,2,…,m$有$\sum_{l\in T_i}p_l\le 1 + \epsilon$, 则$T\in M_\epsilon^h(I)$</p>
</li>
<li><p>定义满足如下条件的算法A为U的<strong>$h-$对偶$\epsilon-$近似算法</strong>: 对所有$x\in L_I$, 有</p>
<ul>
<li><p>$A(x)\in M_\epsilon^h(x)$</p>
</li>
<li><p>如果目标是最大化, 则$cost(A(x))\ge Opt_U(x)$, 如果目标是最小化, 则$cost(A(x))\le Opt_U(x)$</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>定义满足如下条件的算法A为U的<strong>$h-$对偶多项式时间近似方案(h-dual PTAS for U)</strong>:</p>
<ul>
<li><p>对于任意输入$(x,\epsilon)\in L_I\times \mathbb R^+$, $A(x, \epsilon)\in M_\epsilon^h(x)$</p>
</li>
<li><p>如果目标是最大化, 则$cost(A(x,\epsilon))\ge Opt_U(x)$, 如果目标是最小化, 则$cost(A(x,\epsilon))\le Opt_U(x)$</p>
</li>
<li><p>$Time_A(x, \epsilon^{-1})$有$|x|$的多项式函数上界</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>如果$Time_A(x, \epsilon^{-1})$有$|x|$和$\epsilon$的多项式函数上界, 则A为U的<strong>$h-$对偶完全多项式时间近似方案(h-dual FPTAS for U)</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">XY</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XY</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
